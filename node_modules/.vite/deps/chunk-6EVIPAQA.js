import {
  require_nacl_fast
} from "./chunk-U5HU6PWG.js";
import {
  __commonJS,
  __toESM
} from "./chunk-7D4SUZUM.js";

// node_modules/tweetnacl-util/nacl-util.js
var require_nacl_util = __commonJS({
  "node_modules/tweetnacl-util/nacl-util.js"(exports, module) {
    (function(root, f) {
      "use strict";
      if (typeof module !== "undefined" && module.exports) module.exports = f();
      else if (root.nacl) root.nacl.util = f();
      else {
        root.nacl = {};
        root.nacl.util = f();
      }
    })(exports, function() {
      "use strict";
      var util = {};
      function validateBase64(s) {
        if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s)) {
          throw new TypeError("invalid encoding");
        }
      }
      util.decodeUTF8 = function(s) {
        if (typeof s !== "string") throw new TypeError("expected string");
        var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
        for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
        return b;
      };
      util.encodeUTF8 = function(arr) {
        var i, s = [];
        for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));
        return decodeURIComponent(escape(s.join("")));
      };
      if (typeof atob === "undefined") {
        if (typeof Buffer.from !== "undefined") {
          util.encodeBase64 = function(arr) {
            return Buffer.from(arr).toString("base64");
          };
          util.decodeBase64 = function(s) {
            validateBase64(s);
            return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, "base64"), 0));
          };
        } else {
          util.encodeBase64 = function(arr) {
            return new Buffer(arr).toString("base64");
          };
          util.decodeBase64 = function(s) {
            validateBase64(s);
            return new Uint8Array(Array.prototype.slice.call(new Buffer(s, "base64"), 0));
          };
        }
      } else {
        util.encodeBase64 = function(arr) {
          var i, s = [], len = arr.length;
          for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));
          return btoa(s.join(""));
        };
        util.decodeBase64 = function(s) {
          validateBase64(s);
          var i, d = atob(s), b = new Uint8Array(d.length);
          for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
          return b;
        };
      }
      return util;
    });
  }
});

// node_modules/@tonconnect/protocol/lib/esm/index.mjs
var import_tweetnacl_util = __toESM(require_nacl_util(), 1);
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var CONNECT_EVENT_ERROR_CODES;
(function(CONNECT_EVENT_ERROR_CODES2) {
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["MANIFEST_NOT_FOUND_ERROR"] = 2] = "MANIFEST_NOT_FOUND_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["MANIFEST_CONTENT_ERROR"] = 3] = "MANIFEST_CONTENT_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));
var CONNECT_ITEM_ERROR_CODES;
(function(CONNECT_ITEM_ERROR_CODES2) {
  CONNECT_ITEM_ERROR_CODES2[CONNECT_ITEM_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  CONNECT_ITEM_ERROR_CODES2[CONNECT_ITEM_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));
var SEND_TRANSACTION_ERROR_CODES;
(function(SEND_TRANSACTION_ERROR_CODES2) {
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));
var SIGN_DATA_ERROR_CODES;
(function(SIGN_DATA_ERROR_CODES2) {
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));
var DISCONNECT_ERROR_CODES;
(function(DISCONNECT_ERROR_CODES2) {
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));
var CHAIN;
(function(CHAIN2) {
  CHAIN2["MAINNET"] = "-239";
  CHAIN2["TESTNET"] = "-3";
})(CHAIN || (CHAIN = {}));
function encodeUint8Array(value, urlSafe) {
  const encoded = import_tweetnacl_util.default.encodeBase64(value);
  if (!urlSafe) {
    return encoded;
  }
  return encodeURIComponent(encoded);
}
function decodeToUint8Array(value, urlSafe) {
  if (urlSafe) {
    value = decodeURIComponent(value);
  }
  return import_tweetnacl_util.default.decodeBase64(value);
}
function encode(value, urlSafe = false) {
  let uint8Array;
  if (value instanceof Uint8Array) {
    uint8Array = value;
  } else {
    if (typeof value !== "string") {
      value = JSON.stringify(value);
    }
    uint8Array = import_tweetnacl_util.default.decodeUTF8(value);
  }
  return encodeUint8Array(uint8Array, urlSafe);
}
function decode(value, urlSafe = false) {
  const decodedUint8Array = decodeToUint8Array(value, urlSafe);
  return {
    toString() {
      return import_tweetnacl_util.default.encodeUTF8(decodedUint8Array);
    },
    toObject() {
      try {
        return JSON.parse(import_tweetnacl_util.default.encodeUTF8(decodedUint8Array));
      } catch (e) {
        return null;
      }
    },
    toUint8Array() {
      return decodedUint8Array;
    }
  };
}
var Base64 = {
  encode,
  decode
};
function concatUint8Arrays(buffer1, buffer2) {
  const mergedArray = new Uint8Array(buffer1.length + buffer2.length);
  mergedArray.set(buffer1);
  mergedArray.set(buffer2, buffer1.length);
  return mergedArray;
}
function splitToUint8Arrays(array, index) {
  if (index >= array.length) {
    throw new Error("Index is out of buffer");
  }
  const subArray1 = array.slice(0, index);
  const subArray2 = array.slice(index);
  return [subArray1, subArray2];
}
function toHexString(byteArray) {
  let hexString = "";
  byteArray.forEach((byte) => {
    hexString += ("0" + (byte & 255).toString(16)).slice(-2);
  });
  return hexString;
}
function hexToByteArray(hexString) {
  if (hexString.length % 2 !== 0) {
    throw new Error(`Cannot convert ${hexString} to bytesArray`);
  }
  const result = new Uint8Array(hexString.length / 2);
  for (let i = 0; i < hexString.length; i += 2) {
    result[i / 2] = parseInt(hexString.slice(i, i + 2), 16);
  }
  return result;
}
var SessionCrypto = class {
  constructor(keyPair) {
    this.nonceLength = 24;
    this.keyPair = keyPair ? this.createKeypairFromString(keyPair) : this.createKeypair();
    this.sessionId = toHexString(this.keyPair.publicKey);
  }
  createKeypair() {
    return import_tweetnacl.default.box.keyPair();
  }
  createKeypairFromString(keyPair) {
    return {
      publicKey: hexToByteArray(keyPair.publicKey),
      secretKey: hexToByteArray(keyPair.secretKey)
    };
  }
  createNonce() {
    return import_tweetnacl.default.randomBytes(this.nonceLength);
  }
  encrypt(message, receiverPublicKey) {
    const encodedMessage = new TextEncoder().encode(message);
    const nonce = this.createNonce();
    const encrypted = import_tweetnacl.default.box(encodedMessage, nonce, receiverPublicKey, this.keyPair.secretKey);
    return concatUint8Arrays(nonce, encrypted);
  }
  decrypt(message, senderPublicKey) {
    const [nonce, internalMessage] = splitToUint8Arrays(message, this.nonceLength);
    const decrypted = import_tweetnacl.default.box.open(internalMessage, nonce, senderPublicKey, this.keyPair.secretKey);
    if (!decrypted) {
      throw new Error(`Decryption error: 
 message: ${message.toString()} 
 sender pubkey: ${senderPublicKey.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);
    }
    return new TextDecoder().decode(decrypted);
  }
  stringifyKeypair() {
    return {
      publicKey: toHexString(this.keyPair.publicKey),
      secretKey: toHexString(this.keyPair.secretKey)
    };
  }
};

// node_modules/@tonconnect/isomorphic-eventsource/browser.js
{
}

// node_modules/@tonconnect/isomorphic-fetch/browser.js
{
}

// node_modules/@tonconnect/sdk/lib/esm/index.mjs
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var TonConnectError = class _TonConnectError extends Error {
  get info() {
    return "";
  }
  constructor(message, options) {
    super(message, options);
    this.message = `${_TonConnectError.prefix} ${this.constructor.name}${this.info ? ": " + this.info : ""}${message ? "\n" + message : ""}`;
    Object.setPrototypeOf(this, _TonConnectError.prototype);
  }
};
TonConnectError.prefix = "[TON_CONNECT_SDK_ERROR]";
var DappMetadataError = class _DappMetadataError extends TonConnectError {
  get info() {
    return "Passed DappMetadata is in incorrect format.";
  }
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _DappMetadataError.prototype);
  }
};
var ManifestContentErrorError = class _ManifestContentErrorError extends TonConnectError {
  get info() {
    return "Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest";
  }
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _ManifestContentErrorError.prototype);
  }
};
var ManifestNotFoundError = class _ManifestNotFoundError extends TonConnectError {
  get info() {
    return "Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest";
  }
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _ManifestNotFoundError.prototype);
  }
};
var WalletAlreadyConnectedError = class _WalletAlreadyConnectedError extends TonConnectError {
  get info() {
    return "Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.";
  }
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _WalletAlreadyConnectedError.prototype);
  }
};
var WalletNotConnectedError = class _WalletNotConnectedError extends TonConnectError {
  get info() {
    return "Send transaction or other protocol methods called while wallet is not connected.";
  }
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _WalletNotConnectedError.prototype);
  }
};
var WalletNotInjectedError = class _WalletNotInjectedError extends TonConnectError {
  get info() {
    return "There is an attempt to connect to the injected wallet while it is not exists in the webpage.";
  }
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _WalletNotInjectedError.prototype);
  }
};
var WalletNotSupportFeatureError = class _WalletNotSupportFeatureError extends TonConnectError {
  get info() {
    return "Wallet doesn't support requested feature method.";
  }
  constructor(message, options) {
    super(message, options);
    Object.setPrototypeOf(this, _WalletNotSupportFeatureError.prototype);
  }
};
var WalletMissingRequiredFeaturesError = class _WalletMissingRequiredFeaturesError extends TonConnectError {
  get info() {
    return "Missing required features. You need to update your wallet.";
  }
  constructor(message, options) {
    super(message, options);
    Object.setPrototypeOf(this, _WalletMissingRequiredFeaturesError.prototype);
  }
};
function isWalletConnectionSourceJS(value) {
  return "jsBridgeKey" in value;
}
var UserRejectsError = class _UserRejectsError extends TonConnectError {
  get info() {
    return "User rejects the action in the wallet.";
  }
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _UserRejectsError.prototype);
  }
};
var BadRequestError = class _BadRequestError extends TonConnectError {
  get info() {
    return "Request to the wallet contains errors.";
  }
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _BadRequestError.prototype);
  }
};
var UnknownAppError = class _UnknownAppError extends TonConnectError {
  get info() {
    return "App tries to send rpc request to the injected wallet while not connected.";
  }
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _UnknownAppError.prototype);
  }
};
var LocalstorageNotFoundError = class _LocalstorageNotFoundError extends TonConnectError {
  get info() {
    return "Storage was not specified in the `DappMetadata` and default `localStorage` was not detected in the environment.";
  }
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _LocalstorageNotFoundError.prototype);
  }
};
var FetchWalletsError = class _FetchWalletsError extends TonConnectError {
  get info() {
    return "An error occurred while fetching the wallets list.";
  }
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _FetchWalletsError.prototype);
  }
};
var WrongAddressError = class _WrongAddressError extends TonConnectError {
  get info() {
    return "Passed address is in incorrect format.";
  }
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _WrongAddressError.prototype);
  }
};
var ParseHexError = class _ParseHexError extends TonConnectError {
  get info() {
    return "Passed hex is in incorrect format.";
  }
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _ParseHexError.prototype);
  }
};
var UnknownError = class _UnknownError extends TonConnectError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, _UnknownError.prototype);
  }
};
var connectEventErrorsCodes = {
  [CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,
  [CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,
  [CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,
  [CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError,
  [CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR]: ManifestNotFoundError,
  [CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR]: ManifestContentErrorError
};
var ConnectErrorsParser = class {
  parseError(error) {
    let ErrorConstructor = UnknownError;
    if (error.code in connectEventErrorsCodes) {
      ErrorConstructor = connectEventErrorsCodes[error.code] || UnknownError;
    }
    return new ErrorConstructor(error.message);
  }
};
var connectErrorsParser = new ConnectErrorsParser();
var RpcParser = class {
  isError(response) {
    return "error" in response;
  }
};
var sendTransactionErrors = {
  [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,
  [SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,
  [SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,
  [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError
};
var SendTransactionParser = class extends RpcParser {
  convertToRpcRequest(request) {
    return {
      method: "sendTransaction",
      params: [JSON.stringify(request)]
    };
  }
  parseAndThrowError(response) {
    let ErrorConstructor = UnknownError;
    if (response.error.code in sendTransactionErrors) {
      ErrorConstructor = sendTransactionErrors[response.error.code] || UnknownError;
    }
    throw new ErrorConstructor(response.error.message);
  }
  convertFromRpcResponse(rpcResponse) {
    return {
      boc: rpcResponse.result
    };
  }
};
var sendTransactionParser = new SendTransactionParser();
var signDataErrors = {
  [SIGN_DATA_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,
  [SIGN_DATA_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,
  [SIGN_DATA_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,
  [SIGN_DATA_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError
};
var SignDataParser = class extends RpcParser {
  convertToRpcRequest(payload) {
    return {
      method: "signData",
      params: [JSON.stringify(payload)]
    };
  }
  parseAndThrowError(response) {
    let ErrorConstructor = UnknownError;
    if (response.error.code in signDataErrors) {
      ErrorConstructor = signDataErrors[response.error.code] || UnknownError;
    }
    throw new ErrorConstructor(response.error.message);
  }
  convertFromRpcResponse(rpcResponse) {
    return rpcResponse.result;
  }
};
var signDataParser = new SignDataParser();
var HttpBridgeGatewayStorage = class {
  constructor(storage, bridgeUrl) {
    this.storage = storage;
    this.storeKey = "ton-connect-storage_http-bridge-gateway::" + bridgeUrl;
  }
  storeLastEventId(lastEventId) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.storage.setItem(this.storeKey, lastEventId);
    });
  }
  removeLastEventId() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.storage.removeItem(this.storeKey);
    });
  }
  getLastEventId() {
    return __awaiter(this, void 0, void 0, function* () {
      const stored = yield this.storage.getItem(this.storeKey);
      if (!stored) {
        return null;
      }
      return stored;
    });
  }
};
function removeUrlLastSlash(url) {
  if (url.slice(-1) === "/") {
    return url.slice(0, -1);
  }
  return url;
}
function addPathToUrl(url, path) {
  return removeUrlLastSlash(url) + "/" + path;
}
function isTelegramUrl(link) {
  if (!link) {
    return false;
  }
  const url = new URL(link);
  return url.protocol === "tg:" || url.hostname === "t.me";
}
function encodeTelegramUrlParameters(parameters) {
  return parameters.replaceAll(".", "%2E").replaceAll("-", "%2D").replaceAll("_", "%5F").replaceAll("&", "-").replaceAll("=", "__").replaceAll("%", "--");
}
function delay(timeout2, options) {
  return __awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      var _a, _b;
      if ((_a = void 0) === null || _a === void 0 ? void 0 : _a.aborted) {
        reject(new TonConnectError("Delay aborted"));
        return;
      }
      const timeoutId = setTimeout(() => resolve(), timeout2);
      (_b = void 0) === null || _b === void 0 ? void 0 : _b.addEventListener("abort", () => {
        clearTimeout(timeoutId);
        reject(new TonConnectError("Delay aborted"));
      });
    });
  });
}
function createAbortController(signal) {
  const abortController = new AbortController();
  if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
    abortController.abort();
  } else {
    signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", () => abortController.abort(), { once: true });
  }
  return abortController;
}
function callForSuccess(fn, options) {
  return __awaiter(this, void 0, void 0, function* () {
    var _a, _b;
    const attempts = (_a = options === null || options === void 0 ? void 0 : options.attempts) !== null && _a !== void 0 ? _a : 10;
    const delayMs = (_b = options === null || options === void 0 ? void 0 : options.delayMs) !== null && _b !== void 0 ? _b : 200;
    const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);
    if (typeof fn !== "function") {
      throw new TonConnectError(`Expected a function, got ${typeof fn}`);
    }
    let i = 0;
    let lastError;
    while (i < attempts) {
      if (abortController.signal.aborted) {
        throw new TonConnectError(`Aborted after attempts ${i}`);
      }
      try {
        return yield fn({ signal: abortController.signal });
      } catch (err) {
        lastError = err;
        i++;
        if (i < attempts) {
          yield delay(delayMs);
        }
      }
    }
    throw lastError;
  });
}
function logDebug(...args) {
  {
    try {
      console.debug("[TON_CONNECT_SDK]", ...args);
    } catch (_a) {
    }
  }
}
function logError(...args) {
  {
    try {
      console.error("[TON_CONNECT_SDK]", ...args);
    } catch (_a) {
    }
  }
}
function logWarning(...args) {
  {
    try {
      console.warn("[TON_CONNECT_SDK]", ...args);
    } catch (_a) {
    }
  }
}
function createResource(createFn, disposeFn) {
  let currentResource = null;
  let currentArgs = null;
  let currentPromise = null;
  let currentSignal = null;
  let abortController = null;
  const create = (signal, ...args) => __awaiter(this, void 0, void 0, function* () {
    currentSignal = signal !== null && signal !== void 0 ? signal : null;
    abortController === null || abortController === void 0 ? void 0 : abortController.abort();
    abortController = createAbortController(signal);
    if (abortController.signal.aborted) {
      throw new TonConnectError("Resource creation was aborted");
    }
    currentArgs = args !== null && args !== void 0 ? args : null;
    const promise = createFn(abortController.signal, ...args);
    currentPromise = promise;
    const resource = yield promise;
    if (currentPromise !== promise && resource !== currentResource) {
      yield disposeFn(resource);
      throw new TonConnectError("Resource creation was aborted by a new resource creation");
    }
    currentResource = resource;
    return currentResource;
  });
  const current = () => {
    return currentResource !== null && currentResource !== void 0 ? currentResource : null;
  };
  const dispose = () => __awaiter(this, void 0, void 0, function* () {
    try {
      const resource = currentResource;
      currentResource = null;
      const promise = currentPromise;
      currentPromise = null;
      try {
        abortController === null || abortController === void 0 ? void 0 : abortController.abort();
      } catch (e) {
      }
      yield Promise.allSettled([
        resource ? disposeFn(resource) : Promise.resolve(),
        promise ? disposeFn(yield promise) : Promise.resolve()
      ]);
    } catch (e) {
    }
  });
  const recreate = (delayMs) => __awaiter(this, void 0, void 0, function* () {
    const resource = currentResource;
    const promise = currentPromise;
    const args = currentArgs;
    const signal = currentSignal;
    yield delay(delayMs);
    if (resource === currentResource && promise === currentPromise && args === currentArgs && signal === currentSignal) {
      return yield create(currentSignal, ...args !== null && args !== void 0 ? args : []);
    }
    throw new TonConnectError("Resource recreation was aborted by a new resource creation");
  });
  return {
    create,
    current,
    dispose,
    recreate
  };
}
function timeout(fn, options) {
  const timeout2 = options === null || options === void 0 ? void 0 : options.timeout;
  const signal = options === null || options === void 0 ? void 0 : options.signal;
  const abortController = createAbortController(signal);
  return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
    if (abortController.signal.aborted) {
      reject(new TonConnectError("Operation aborted"));
      return;
    }
    let timeoutId;
    if (typeof timeout2 !== "undefined") {
      timeoutId = setTimeout(() => {
        abortController.abort();
        reject(new TonConnectError(`Timeout after ${timeout2}ms`));
      }, timeout2);
    }
    abortController.signal.addEventListener("abort", () => {
      clearTimeout(timeoutId);
      reject(new TonConnectError("Operation aborted"));
    }, { once: true });
    const deferOptions = { timeout: timeout2, abort: abortController.signal };
    yield fn((...args) => {
      clearTimeout(timeoutId);
      resolve(...args);
    }, () => {
      clearTimeout(timeoutId);
      reject();
    }, deferOptions);
  }));
}
var BridgeGateway = class {
  get isReady() {
    const eventSource = this.eventSource.current();
    return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) === EventSource.OPEN;
  }
  get isClosed() {
    const eventSource = this.eventSource.current();
    return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) !== EventSource.OPEN;
  }
  get isConnecting() {
    const eventSource = this.eventSource.current();
    return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) === EventSource.CONNECTING;
  }
  constructor(storage, bridgeUrl, sessionId, listener, errorsListener) {
    this.bridgeUrl = bridgeUrl;
    this.sessionId = sessionId;
    this.listener = listener;
    this.errorsListener = errorsListener;
    this.ssePath = "events";
    this.postPath = "message";
    this.heartbeatMessage = "heartbeat";
    this.defaultTtl = 300;
    this.defaultReconnectDelay = 2e3;
    this.defaultResendDelay = 5e3;
    this.eventSource = createResource((signal, openingDeadlineMS) => __awaiter(this, void 0, void 0, function* () {
      const eventSourceConfig = {
        bridgeUrl: this.bridgeUrl,
        ssePath: this.ssePath,
        sessionId: this.sessionId,
        bridgeGatewayStorage: this.bridgeGatewayStorage,
        errorHandler: this.errorsHandler.bind(this),
        messageHandler: this.messagesHandler.bind(this),
        signal,
        openingDeadlineMS
      };
      return yield createEventSource(eventSourceConfig);
    }), (resource) => __awaiter(this, void 0, void 0, function* () {
      resource.close();
    }));
    this.bridgeGatewayStorage = new HttpBridgeGatewayStorage(storage, bridgeUrl);
  }
  registerSession(options) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.eventSource.create(options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.openingDeadlineMS);
    });
  }
  send(message, receiver, topic, ttlOrOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const options = {};
      if (typeof ttlOrOptions === "number") {
        options.ttl = ttlOrOptions;
      } else {
        options.ttl = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.ttl;
        options.signal = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.signal;
        options.attempts = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.attempts;
      }
      const url = new URL(addPathToUrl(this.bridgeUrl, this.postPath));
      url.searchParams.append("client_id", this.sessionId);
      url.searchParams.append("to", receiver);
      url.searchParams.append("ttl", ((options === null || options === void 0 ? void 0 : options.ttl) || this.defaultTtl).toString());
      url.searchParams.append("topic", topic);
      const body = Base64.encode(message);
      yield callForSuccess((options2) => __awaiter(this, void 0, void 0, function* () {
        const response = yield this.post(url, body, options2.signal);
        if (!response.ok) {
          throw new TonConnectError(`Bridge send failed, status ${response.status}`);
        }
      }), {
        attempts: (_a = options === null || options === void 0 ? void 0 : options.attempts) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER,
        delayMs: this.defaultResendDelay,
        signal: options === null || options === void 0 ? void 0 : options.signal
      });
    });
  }
  pause() {
    this.eventSource.dispose().catch((e) => logError(`Bridge pause failed, ${e}`));
  }
  unPause() {
    return __awaiter(this, void 0, void 0, function* () {
      const RECREATE_WITHOUT_DELAY = 0;
      yield this.eventSource.recreate(RECREATE_WITHOUT_DELAY);
    });
  }
  close() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.eventSource.dispose().catch((e) => logError(`Bridge close failed, ${e}`));
    });
  }
  setListener(listener) {
    this.listener = listener;
  }
  setErrorsListener(errorsListener) {
    this.errorsListener = errorsListener;
  }
  post(url, body, signal) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield fetch(url, {
        method: "post",
        body,
        signal
      });
      if (!response.ok) {
        throw new TonConnectError(`Bridge send failed, status ${response.status}`);
      }
      return response;
    });
  }
  errorsHandler(eventSource, e) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.isConnecting) {
        eventSource.close();
        throw new TonConnectError("Bridge error, failed to connect");
      }
      if (this.isReady) {
        try {
          this.errorsListener(e);
        } catch (e2) {
        }
        return;
      }
      if (this.isClosed) {
        eventSource.close();
        logDebug(`Bridge reconnecting, ${this.defaultReconnectDelay}ms delay`);
        return yield this.eventSource.recreate(this.defaultReconnectDelay);
      }
      throw new TonConnectError("Bridge error, unknown state");
    });
  }
  messagesHandler(e) {
    return __awaiter(this, void 0, void 0, function* () {
      if (e.data === this.heartbeatMessage) {
        return;
      }
      yield this.bridgeGatewayStorage.storeLastEventId(e.lastEventId);
      if (this.isClosed) {
        return;
      }
      let bridgeIncomingMessage;
      try {
        bridgeIncomingMessage = JSON.parse(e.data);
      } catch (_) {
        throw new TonConnectError(`Bridge message parse failed, message ${e.data}`);
      }
      this.listener(bridgeIncomingMessage);
    });
  }
};
function createEventSource(config) {
  return __awaiter(this, void 0, void 0, function* () {
    return yield timeout((resolve, reject, deferOptions) => __awaiter(this, void 0, void 0, function* () {
      var _a;
      const abortController = createAbortController(deferOptions.signal);
      const signal = abortController.signal;
      if (signal.aborted) {
        reject(new TonConnectError("Bridge connection aborted"));
        return;
      }
      const url = new URL(addPathToUrl(config.bridgeUrl, config.ssePath));
      url.searchParams.append("client_id", config.sessionId);
      const lastEventId = yield config.bridgeGatewayStorage.getLastEventId();
      if (lastEventId) {
        url.searchParams.append("last_event_id", lastEventId);
      }
      if (signal.aborted) {
        reject(new TonConnectError("Bridge connection aborted"));
        return;
      }
      const eventSource = new EventSource(url.toString());
      eventSource.onerror = (reason) => __awaiter(this, void 0, void 0, function* () {
        if (signal.aborted) {
          eventSource.close();
          reject(new TonConnectError("Bridge connection aborted"));
          return;
        }
        try {
          const newInstance = yield config.errorHandler(eventSource, reason);
          if (newInstance !== eventSource) {
            eventSource.close();
          }
          if (newInstance && newInstance !== eventSource) {
            resolve(newInstance);
          }
        } catch (e) {
          eventSource.close();
          reject(e);
        }
      });
      eventSource.onopen = () => {
        if (signal.aborted) {
          eventSource.close();
          reject(new TonConnectError("Bridge connection aborted"));
          return;
        }
        resolve(eventSource);
      };
      eventSource.onmessage = (event) => {
        if (signal.aborted) {
          eventSource.close();
          reject(new TonConnectError("Bridge connection aborted"));
          return;
        }
        config.messageHandler(event);
      };
      (_a = config.signal) === null || _a === void 0 ? void 0 : _a.addEventListener("abort", () => {
        eventSource.close();
        reject(new TonConnectError("Bridge connection aborted"));
      });
    }), { timeout: config.openingDeadlineMS, signal: config.signal });
  });
}
var CONNECTION_HTTP_EXPIRATION_TIME = 5 * 60 * 1e3;
function isPendingConnectionHttp(connection) {
  return !("connectEvent" in connection);
}
function isPendingConnectionHttpRaw(connection) {
  return !("connectEvent" in connection);
}
function isExpiredPendingConnectionHttpRaw(connection) {
  var _a;
  return Date.now() - ((_a = connection.createdAt) !== null && _a !== void 0 ? _a : 0) > CONNECTION_HTTP_EXPIRATION_TIME;
}
var BridgeConnectionStorage = class {
  constructor(storage) {
    this.storage = storage;
    this.storeKey = "ton-connect-storage_bridge-connection";
  }
  storeConnection(connection) {
    return __awaiter(this, void 0, void 0, function* () {
      if (connection.type === "injected") {
        return this.storage.setItem(this.storeKey, JSON.stringify(connection));
      }
      if (!isPendingConnectionHttp(connection)) {
        const rawSession = {
          sessionKeyPair: connection.session.sessionCrypto.stringifyKeypair(),
          walletPublicKey: connection.session.walletPublicKey,
          bridgeUrl: connection.session.bridgeUrl
        };
        const rawConnection2 = {
          type: "http",
          connectEvent: connection.connectEvent,
          session: rawSession,
          lastWalletEventId: connection.lastWalletEventId,
          nextRpcRequestId: connection.nextRpcRequestId
        };
        return this.storage.setItem(this.storeKey, JSON.stringify(rawConnection2));
      }
      const rawConnection = {
        type: "http",
        connectionSource: connection.connectionSource,
        sessionCrypto: connection.sessionCrypto.stringifyKeypair(),
        createdAt: Date.now()
      };
      return this.storage.setItem(this.storeKey, JSON.stringify(rawConnection));
    });
  }
  removeConnection() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.storage.removeItem(this.storeKey);
    });
  }
  getConnection() {
    return __awaiter(this, void 0, void 0, function* () {
      const stored = yield this.storage.getItem(this.storeKey);
      if (!stored) {
        return null;
      }
      const connection = JSON.parse(stored);
      if (connection.type === "injected") {
        return connection;
      }
      if (!isPendingConnectionHttpRaw(connection)) {
        const sessionCrypto = new SessionCrypto(connection.session.sessionKeyPair);
        return {
          type: "http",
          connectEvent: connection.connectEvent,
          lastWalletEventId: connection.lastWalletEventId,
          nextRpcRequestId: connection.nextRpcRequestId,
          session: {
            sessionCrypto,
            bridgeUrl: connection.session.bridgeUrl,
            walletPublicKey: connection.session.walletPublicKey
          }
        };
      }
      if (isExpiredPendingConnectionHttpRaw(connection)) {
        yield this.removeConnection();
        return null;
      }
      return {
        type: "http",
        sessionCrypto: new SessionCrypto(connection.sessionCrypto),
        connectionSource: connection.connectionSource
      };
    });
  }
  getHttpConnection() {
    return __awaiter(this, void 0, void 0, function* () {
      const connection = yield this.getConnection();
      if (!connection) {
        throw new TonConnectError("Trying to read HTTP connection source while nothing is stored");
      }
      if (connection.type === "injected") {
        throw new TonConnectError("Trying to read HTTP connection source while injected connection is stored");
      }
      return connection;
    });
  }
  getHttpPendingConnection() {
    return __awaiter(this, void 0, void 0, function* () {
      const connection = yield this.getConnection();
      if (!connection) {
        throw new TonConnectError("Trying to read HTTP connection source while nothing is stored");
      }
      if (connection.type === "injected") {
        throw new TonConnectError("Trying to read HTTP connection source while injected connection is stored");
      }
      if (!isPendingConnectionHttp(connection)) {
        throw new TonConnectError("Trying to read HTTP-pending connection while http connection is stored");
      }
      return connection;
    });
  }
  getInjectedConnection() {
    return __awaiter(this, void 0, void 0, function* () {
      const connection = yield this.getConnection();
      if (!connection) {
        throw new TonConnectError("Trying to read Injected bridge connection source while nothing is stored");
      }
      if ((connection === null || connection === void 0 ? void 0 : connection.type) === "http") {
        throw new TonConnectError("Trying to read Injected bridge connection source while HTTP connection is stored");
      }
      return connection;
    });
  }
  storedConnectionType() {
    return __awaiter(this, void 0, void 0, function* () {
      const stored = yield this.storage.getItem(this.storeKey);
      if (!stored) {
        return null;
      }
      const connection = JSON.parse(stored);
      return connection.type;
    });
  }
  storeLastWalletEventId(id) {
    return __awaiter(this, void 0, void 0, function* () {
      const connection = yield this.getConnection();
      if (connection && connection.type === "http" && !isPendingConnectionHttp(connection)) {
        connection.lastWalletEventId = id;
        return this.storeConnection(connection);
      }
    });
  }
  getLastWalletEventId() {
    return __awaiter(this, void 0, void 0, function* () {
      const connection = yield this.getConnection();
      if (connection && "lastWalletEventId" in connection) {
        return connection.lastWalletEventId;
      }
      return void 0;
    });
  }
  increaseNextRpcRequestId() {
    return __awaiter(this, void 0, void 0, function* () {
      const connection = yield this.getConnection();
      if (connection && "nextRpcRequestId" in connection) {
        const lastId = connection.nextRpcRequestId || 0;
        connection.nextRpcRequestId = lastId + 1;
        return this.storeConnection(connection);
      }
    });
  }
  getNextRpcRequestId() {
    return __awaiter(this, void 0, void 0, function* () {
      const connection = yield this.getConnection();
      if (connection && "nextRpcRequestId" in connection) {
        return connection.nextRpcRequestId || 0;
      }
      return 0;
    });
  }
};
var PROTOCOL_VERSION = 2;
var BridgeProvider = class _BridgeProvider {
  static fromStorage(storage) {
    return __awaiter(this, void 0, void 0, function* () {
      const bridgeConnectionStorage = new BridgeConnectionStorage(storage);
      const connection = yield bridgeConnectionStorage.getHttpConnection();
      if (isPendingConnectionHttp(connection)) {
        return new _BridgeProvider(storage, connection.connectionSource);
      }
      return new _BridgeProvider(storage, { bridgeUrl: connection.session.bridgeUrl });
    });
  }
  constructor(storage, walletConnectionSource) {
    this.storage = storage;
    this.walletConnectionSource = walletConnectionSource;
    this.type = "http";
    this.standardUniversalLink = "tc://";
    this.pendingRequests = /* @__PURE__ */ new Map();
    this.session = null;
    this.gateway = null;
    this.pendingGateways = [];
    this.listeners = [];
    this.defaultOpeningDeadlineMS = 12e3;
    this.defaultRetryTimeoutMS = 2e3;
    this.connectionStorage = new BridgeConnectionStorage(storage);
  }
  connect(message, options) {
    var _a;
    const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);
    (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();
    this.abortController = abortController;
    this.closeGateways();
    const sessionCrypto = new SessionCrypto();
    this.session = {
      sessionCrypto,
      bridgeUrl: "bridgeUrl" in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
    };
    this.connectionStorage.storeConnection({
      type: "http",
      connectionSource: this.walletConnectionSource,
      sessionCrypto
    }).then(() => __awaiter(this, void 0, void 0, function* () {
      if (abortController.signal.aborted) {
        return;
      }
      yield callForSuccess((_options) => {
        var _a2;
        return this.openGateways(sessionCrypto, {
          openingDeadlineMS: (_a2 = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _a2 !== void 0 ? _a2 : this.defaultOpeningDeadlineMS,
          signal: _options === null || _options === void 0 ? void 0 : _options.signal
        });
      }, {
        attempts: Number.MAX_SAFE_INTEGER,
        delayMs: this.defaultRetryTimeoutMS,
        signal: abortController.signal
      });
    }));
    const universalLink = "universalLink" in this.walletConnectionSource && this.walletConnectionSource.universalLink ? this.walletConnectionSource.universalLink : this.standardUniversalLink;
    return this.generateUniversalLink(universalLink, message);
  }
  restoreConnection(options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);
      (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();
      this.abortController = abortController;
      if (abortController.signal.aborted) {
        return;
      }
      this.closeGateways();
      const storedConnection = yield this.connectionStorage.getHttpConnection();
      if (!storedConnection) {
        return;
      }
      if (abortController.signal.aborted) {
        return;
      }
      const openingDeadlineMS = (_b = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _b !== void 0 ? _b : this.defaultOpeningDeadlineMS;
      if (isPendingConnectionHttp(storedConnection)) {
        this.session = {
          sessionCrypto: storedConnection.sessionCrypto,
          bridgeUrl: "bridgeUrl" in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
        };
        return yield this.openGateways(storedConnection.sessionCrypto, {
          openingDeadlineMS,
          signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal
        });
      }
      if (Array.isArray(this.walletConnectionSource)) {
        throw new TonConnectError("Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.");
      }
      this.session = storedConnection.session;
      if (this.gateway) {
        logDebug("Gateway is already opened, closing previous gateway");
        yield this.gateway.close();
      }
      this.gateway = new BridgeGateway(this.storage, this.walletConnectionSource.bridgeUrl, storedConnection.session.sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this));
      if (abortController.signal.aborted) {
        return;
      }
      this.listeners.forEach((listener) => listener(storedConnection.connectEvent));
      try {
        yield callForSuccess((options2) => this.gateway.registerSession({
          openingDeadlineMS,
          signal: options2.signal
        }), {
          attempts: Number.MAX_SAFE_INTEGER,
          delayMs: this.defaultRetryTimeoutMS,
          signal: abortController.signal
        });
      } catch (e) {
        yield this.disconnect({ signal: abortController.signal });
        return;
      }
    });
  }
  sendRequest(request, optionsOrOnRequestSent) {
    const options = {};
    if (typeof optionsOrOnRequestSent === "function") {
      options.onRequestSent = optionsOrOnRequestSent;
    } else {
      options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;
      options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;
      options.attempts = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.attempts;
    }
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      var _a;
      if (!this.gateway || !this.session || !("walletPublicKey" in this.session)) {
        throw new TonConnectError("Trying to send bridge request without session");
      }
      const id = (yield this.connectionStorage.getNextRpcRequestId()).toString();
      yield this.connectionStorage.increaseNextRpcRequestId();
      logDebug("Send http-bridge request:", Object.assign(Object.assign({}, request), { id }));
      const encodedRequest = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, request), { id })), hexToByteArray(this.session.walletPublicKey));
      try {
        yield this.gateway.send(encodedRequest, this.session.walletPublicKey, request.method, { attempts: options === null || options === void 0 ? void 0 : options.attempts, signal: options === null || options === void 0 ? void 0 : options.signal });
        (_a = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _a === void 0 ? void 0 : _a.call(options);
        this.pendingRequests.set(id.toString(), resolve);
      } catch (e) {
        reject(e);
      }
    }));
  }
  closeConnection() {
    this.closeGateways();
    this.listeners = [];
    this.session = null;
    this.gateway = null;
  }
  disconnect(options) {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
        let called = false;
        let timeoutId = null;
        const onRequestSent = () => {
          if (!called) {
            called = true;
            this.removeBridgeAndSession().then(resolve);
          }
        };
        try {
          this.closeGateways();
          const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);
          timeoutId = setTimeout(() => {
            abortController.abort();
          }, this.defaultOpeningDeadlineMS);
          yield this.sendRequest({ method: "disconnect", params: [] }, {
            onRequestSent,
            signal: abortController.signal,
            attempts: 1
          });
        } catch (e) {
          logDebug("Disconnect error:", e);
          if (!called) {
            this.removeBridgeAndSession().then(resolve);
          }
        } finally {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          onRequestSent();
        }
      }));
    });
  }
  listen(callback) {
    this.listeners.push(callback);
    return () => this.listeners = this.listeners.filter((listener) => listener !== callback);
  }
  pause() {
    var _a;
    (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.pause();
    this.pendingGateways.forEach((bridge) => bridge.pause());
  }
  unPause() {
    return __awaiter(this, void 0, void 0, function* () {
      const promises = this.pendingGateways.map((bridge) => bridge.unPause());
      if (this.gateway) {
        promises.push(this.gateway.unPause());
      }
      yield Promise.all(promises);
    });
  }
  pendingGatewaysListener(gateway, bridgeUrl, bridgeIncomingMessage) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.pendingGateways.includes(gateway)) {
        yield gateway.close();
        return;
      }
      this.closeGateways({ except: gateway });
      if (this.gateway) {
        logDebug("Gateway is already opened, closing previous gateway");
        yield this.gateway.close();
      }
      this.session.bridgeUrl = bridgeUrl;
      this.gateway = gateway;
      this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this));
      this.gateway.setListener(this.gatewayListener.bind(this));
      return this.gatewayListener(bridgeIncomingMessage);
    });
  }
  gatewayListener(bridgeIncomingMessage) {
    return __awaiter(this, void 0, void 0, function* () {
      const walletMessage = JSON.parse(this.session.sessionCrypto.decrypt(Base64.decode(bridgeIncomingMessage.message).toUint8Array(), hexToByteArray(bridgeIncomingMessage.from)));
      logDebug("Wallet message received:", walletMessage);
      if (!("event" in walletMessage)) {
        const id = walletMessage.id.toString();
        const resolve = this.pendingRequests.get(id);
        if (!resolve) {
          logDebug(`Response id ${id} doesn't match any request's id`);
          return;
        }
        resolve(walletMessage);
        this.pendingRequests.delete(id);
        return;
      }
      if (walletMessage.id !== void 0) {
        const lastId = yield this.connectionStorage.getLastWalletEventId();
        if (lastId !== void 0 && walletMessage.id <= lastId) {
          logError(`Received event id (=${walletMessage.id}) must be greater than stored last wallet event id (=${lastId}) `);
          return;
        }
        if (walletMessage.event !== "connect") {
          yield this.connectionStorage.storeLastWalletEventId(walletMessage.id);
        }
      }
      const listeners = this.listeners;
      if (walletMessage.event === "connect") {
        yield this.updateSession(walletMessage, bridgeIncomingMessage.from);
      }
      if (walletMessage.event === "disconnect") {
        logDebug(`Removing bridge and session: received disconnect event`);
        yield this.removeBridgeAndSession();
      }
      listeners.forEach((listener) => listener(walletMessage));
    });
  }
  gatewayErrorsListener(e) {
    return __awaiter(this, void 0, void 0, function* () {
      throw new TonConnectError(`Bridge error ${JSON.stringify(e)}`);
    });
  }
  updateSession(connectEvent, walletPublicKey) {
    return __awaiter(this, void 0, void 0, function* () {
      this.session = Object.assign(Object.assign({}, this.session), { walletPublicKey });
      const tonAddrItem = connectEvent.payload.items.find((item) => item.name === "ton_addr");
      const connectEventToSave = Object.assign(Object.assign({}, connectEvent), { payload: Object.assign(Object.assign({}, connectEvent.payload), { items: [tonAddrItem] }) });
      yield this.connectionStorage.storeConnection({
        type: "http",
        session: this.session,
        lastWalletEventId: connectEvent.id,
        connectEvent: connectEventToSave,
        nextRpcRequestId: 0
      });
    });
  }
  removeBridgeAndSession() {
    return __awaiter(this, void 0, void 0, function* () {
      this.closeConnection();
      yield this.connectionStorage.removeConnection();
    });
  }
  generateUniversalLink(universalLink, message) {
    if (isTelegramUrl(universalLink)) {
      return this.generateTGUniversalLink(universalLink, message);
    }
    return this.generateRegularUniversalLink(universalLink, message);
  }
  generateRegularUniversalLink(universalLink, message) {
    const url = new URL(universalLink);
    url.searchParams.append("v", PROTOCOL_VERSION.toString());
    url.searchParams.append("id", this.session.sessionCrypto.sessionId);
    url.searchParams.append("r", JSON.stringify(message));
    return url.toString();
  }
  generateTGUniversalLink(universalLink, message) {
    const urlToWrap = this.generateRegularUniversalLink("about:blank", message);
    const linkParams = urlToWrap.split("?")[1];
    const startapp = "tonconnect-" + encodeTelegramUrlParameters(linkParams);
    const updatedUniversalLink = this.convertToDirectLink(universalLink);
    const url = new URL(updatedUniversalLink);
    url.searchParams.append("startapp", startapp);
    return url.toString();
  }
  // TODO: Remove this method after all dApps and the wallets-list.json have been updated
  convertToDirectLink(universalLink) {
    const url = new URL(universalLink);
    if (url.searchParams.has("attach")) {
      url.searchParams.delete("attach");
      url.pathname += "/start";
    }
    return url.toString();
  }
  openGateways(sessionCrypto, options) {
    return __awaiter(this, void 0, void 0, function* () {
      if (Array.isArray(this.walletConnectionSource)) {
        this.pendingGateways.map((bridge) => bridge.close().catch());
        this.pendingGateways = this.walletConnectionSource.map((source) => {
          const gateway = new BridgeGateway(this.storage, source.bridgeUrl, sessionCrypto.sessionId, () => {
          }, () => {
          });
          gateway.setListener((message) => this.pendingGatewaysListener(gateway, source.bridgeUrl, message));
          return gateway;
        });
        yield Promise.allSettled(this.pendingGateways.map((bridge) => callForSuccess((_options) => {
          var _a;
          if (!this.pendingGateways.some((item) => item === bridge)) {
            return bridge.close();
          }
          return bridge.registerSession({
            openingDeadlineMS: (_a = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _a !== void 0 ? _a : this.defaultOpeningDeadlineMS,
            signal: _options.signal
          });
        }, {
          attempts: Number.MAX_SAFE_INTEGER,
          delayMs: this.defaultRetryTimeoutMS,
          signal: options === null || options === void 0 ? void 0 : options.signal
        })));
        return;
      } else {
        if (this.gateway) {
          logDebug(`Gateway is already opened, closing previous gateway`);
          yield this.gateway.close();
        }
        this.gateway = new BridgeGateway(this.storage, this.walletConnectionSource.bridgeUrl, sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this));
        return yield this.gateway.registerSession({
          openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,
          signal: options === null || options === void 0 ? void 0 : options.signal
        });
      }
    });
  }
  closeGateways(options) {
    var _a;
    (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.close();
    this.pendingGateways.filter((item) => item !== (options === null || options === void 0 ? void 0 : options.except)).forEach((bridge) => bridge.close());
    this.pendingGateways = [];
  }
};
function hasProperty(value, propertyKey) {
  return hasProperties(value, [propertyKey]);
}
function hasProperties(value, propertyKeys) {
  if (!value || typeof value !== "object") {
    return false;
  }
  return propertyKeys.every((propertyKey) => propertyKey in value);
}
function isJSBridgeWithMetadata(value) {
  try {
    if (!hasProperty(value, "tonconnect") || !hasProperty(value.tonconnect, "walletInfo")) {
      return false;
    }
    return hasProperties(value.tonconnect.walletInfo, [
      "name",
      "app_name",
      "image",
      "about_url",
      "platforms"
    ]);
  } catch (_a) {
    return false;
  }
}
var InMemoryStorage = class _InMemoryStorage {
  static getInstance() {
    if (!_InMemoryStorage.instance) {
      _InMemoryStorage.instance = new _InMemoryStorage();
    }
    return _InMemoryStorage.instance;
  }
  constructor() {
    this.storage = {};
  }
  get length() {
    return Object.keys(this.storage).length;
  }
  clear() {
    this.storage = {};
  }
  getItem(key) {
    var _a;
    return (_a = this.storage[key]) !== null && _a !== void 0 ? _a : null;
  }
  key(index) {
    var _a;
    const keys = Object.keys(this.storage);
    if (index < 0 || index >= keys.length) {
      return null;
    }
    return (_a = keys[index]) !== null && _a !== void 0 ? _a : null;
  }
  removeItem(key) {
    delete this.storage[key];
  }
  setItem(key, value) {
    this.storage[key] = value;
  }
};
function getWindow() {
  if (typeof window === "undefined") {
    return void 0;
  }
  return window;
}
function getDocument() {
  if (typeof document === "undefined") {
    return void 0;
  }
  return document;
}
function getWebPageManifest() {
  var _a;
  const origin = (_a = getWindow()) === null || _a === void 0 ? void 0 : _a.location.origin;
  if (origin) {
    return origin + "/tonconnect-manifest.json";
  }
  return "";
}
function tryGetLocalStorage() {
  if (isLocalStorageAvailable()) {
    return localStorage;
  }
  if (isNodeJs()) {
    throw new TonConnectError("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
  }
  return InMemoryStorage.getInstance();
}
function isLocalStorageAvailable() {
  try {
    return typeof localStorage !== "undefined";
  } catch (_a) {
    return false;
  }
}
function isNodeJs() {
  return typeof process !== "undefined" && process.versions != null && process.versions.node != null;
}
function getDomain() {
  try {
    if (typeof window !== "undefined" && window.location) {
      return window.location.hostname;
    } else {
      return null;
    }
  } catch (_a) {
    return null;
  }
}
function getWindowEntries() {
  const window2 = getWindow();
  if (!window2) {
    return [];
  }
  try {
    return Object.entries(window2);
  } catch (_a) {
    return [];
  }
}
var InjectedProvider = class _InjectedProvider {
  static fromStorage(storage) {
    return __awaiter(this, void 0, void 0, function* () {
      const bridgeConnectionStorage = new BridgeConnectionStorage(storage);
      const connection = yield bridgeConnectionStorage.getInjectedConnection();
      return new _InjectedProvider(storage, connection.jsBridgeKey);
    });
  }
  static isWalletInjected(injectedWalletKey) {
    return _InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey);
  }
  static isInsideWalletBrowser(injectedWalletKey) {
    if (_InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey)) {
      return this.window[injectedWalletKey].tonconnect.isWalletBrowser;
    }
    return false;
  }
  static getCurrentlyInjectedWallets() {
    if (!this.window) {
      return [];
    }
    const windowEntries = getWindowEntries();
    const wallets = windowEntries.filter(([_key, value]) => isJSBridgeWithMetadata(value));
    return wallets.map(([jsBridgeKey, wallet]) => ({
      name: wallet.tonconnect.walletInfo.name,
      appName: wallet.tonconnect.walletInfo.app_name,
      aboutUrl: wallet.tonconnect.walletInfo.about_url,
      imageUrl: wallet.tonconnect.walletInfo.image,
      tondns: wallet.tonconnect.walletInfo.tondns,
      jsBridgeKey,
      injected: true,
      embedded: wallet.tonconnect.isWalletBrowser,
      platforms: wallet.tonconnect.walletInfo.platforms,
      features: wallet.tonconnect.walletInfo.features
    }));
  }
  static isWindowContainsWallet(window2, injectedWalletKey) {
    return !!window2 && injectedWalletKey in window2 && typeof window2[injectedWalletKey] === "object" && "tonconnect" in window2[injectedWalletKey];
  }
  constructor(storage, injectedWalletKey) {
    this.injectedWalletKey = injectedWalletKey;
    this.type = "injected";
    this.unsubscribeCallback = null;
    this.listenSubscriptions = false;
    this.listeners = [];
    const window2 = _InjectedProvider.window;
    if (!_InjectedProvider.isWindowContainsWallet(window2, injectedWalletKey)) {
      throw new WalletNotInjectedError();
    }
    this.connectionStorage = new BridgeConnectionStorage(storage);
    this.injectedWallet = window2[injectedWalletKey].tonconnect;
  }
  connect(message) {
    this._connect(PROTOCOL_VERSION, message);
  }
  restoreConnection() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        logDebug(`Injected Provider restoring connection...`);
        const connectEvent = yield this.injectedWallet.restoreConnection();
        logDebug("Injected Provider restoring connection response", connectEvent);
        if (connectEvent.event === "connect") {
          this.makeSubscriptions();
          this.listeners.forEach((listener) => listener(connectEvent));
        } else {
          yield this.connectionStorage.removeConnection();
        }
      } catch (e) {
        yield this.connectionStorage.removeConnection();
        console.error(e);
      }
    });
  }
  closeConnection() {
    if (this.listenSubscriptions) {
      this.injectedWallet.disconnect();
    }
    this.closeAllListeners();
  }
  disconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((resolve) => {
        const onRequestSent = () => {
          this.closeAllListeners();
          this.connectionStorage.removeConnection().then(resolve);
        };
        try {
          this.injectedWallet.disconnect();
          onRequestSent();
        } catch (e) {
          logDebug(e);
          this.sendRequest({
            method: "disconnect",
            params: []
          }, onRequestSent);
        }
      });
    });
  }
  closeAllListeners() {
    var _a;
    this.listenSubscriptions = false;
    this.listeners = [];
    (_a = this.unsubscribeCallback) === null || _a === void 0 ? void 0 : _a.call(this);
  }
  listen(eventsCallback) {
    this.listeners.push(eventsCallback);
    return () => this.listeners = this.listeners.filter((listener) => listener !== eventsCallback);
  }
  sendRequest(request, optionsOrOnRequestSent) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const options = {};
      if (typeof optionsOrOnRequestSent === "function") {
        options.onRequestSent = optionsOrOnRequestSent;
      } else {
        options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;
        options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;
      }
      const id = (yield this.connectionStorage.getNextRpcRequestId()).toString();
      yield this.connectionStorage.increaseNextRpcRequestId();
      logDebug("Send injected-bridge request:", Object.assign(Object.assign({}, request), { id }));
      const result = this.injectedWallet.send(Object.assign(Object.assign({}, request), { id }));
      result.then((response) => logDebug("Wallet message received:", response));
      (_a = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _a === void 0 ? void 0 : _a.call(options);
      return result;
    });
  }
  _connect(protocolVersion, message) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        logDebug(`Injected Provider connect request: protocolVersion: ${protocolVersion}, message:`, message);
        const connectEvent = yield this.injectedWallet.connect(protocolVersion, message);
        logDebug("Injected Provider connect response:", connectEvent);
        if (connectEvent.event === "connect") {
          yield this.updateSession();
          this.makeSubscriptions();
        }
        this.listeners.forEach((listener) => listener(connectEvent));
      } catch (e) {
        logDebug("Injected Provider connect error:", e);
        const connectEventError = {
          event: "connect_error",
          payload: {
            code: 0,
            message: e === null || e === void 0 ? void 0 : e.toString()
          }
        };
        this.listeners.forEach((listener) => listener(connectEventError));
      }
    });
  }
  makeSubscriptions() {
    this.listenSubscriptions = true;
    this.unsubscribeCallback = this.injectedWallet.listen((e) => {
      logDebug("Wallet message received:", e);
      if (this.listenSubscriptions) {
        this.listeners.forEach((listener) => listener(e));
      }
      if (e.event === "disconnect") {
        this.disconnect();
      }
    });
  }
  updateSession() {
    return this.connectionStorage.storeConnection({
      type: "injected",
      jsBridgeKey: this.injectedWalletKey,
      nextRpcRequestId: 0
    });
  }
};
InjectedProvider.window = getWindow();
var DefaultStorage = class {
  constructor() {
    this.localStorage = tryGetLocalStorage();
  }
  getItem(key) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.localStorage.getItem(key);
    });
  }
  removeItem(key) {
    return __awaiter(this, void 0, void 0, function* () {
      this.localStorage.removeItem(key);
    });
  }
  setItem(key, value) {
    return __awaiter(this, void 0, void 0, function* () {
      this.localStorage.setItem(key, value);
    });
  }
};
function isWalletInfoCurrentlyInjected(value) {
  return isWalletInfoInjectable(value) && value.injected;
}
function isWalletInfoCurrentlyEmbedded(value) {
  return isWalletInfoCurrentlyInjected(value) && value.embedded;
}
function isWalletInfoInjectable(value) {
  return "jsBridgeKey" in value;
}
function isWalletInfoRemote(value) {
  return "bridgeUrl" in value;
}
function isWalletInfoInjected(value) {
  return "jsBridgeKey" in value;
}
var FALLBACK_WALLETS_LIST = [
  {
    app_name: "telegram-wallet",
    name: "Wallet",
    image: "https://wallet.tg/images/logo-288.png",
    about_url: "https://wallet.tg/",
    universal_url: "https://t.me/wallet?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://walletbot.me/tonconnect-bridge/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 255,
        extraCurrencySupported: true
      },
      {
        name: "SignData",
        types: ["text", "binary", "cell"]
      }
    ]
  },
  {
    app_name: "tonkeeper",
    name: "Tonkeeper",
    image: "https://tonkeeper.com/assets/tonconnect-icon.png",
    tondns: "tonkeeper.ton",
    about_url: "https://tonkeeper.com",
    universal_url: "https://app.tonkeeper.com/ton-connect",
    deepLink: "tonkeeper-tc://",
    bridge: [
      {
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
      },
      {
        type: "js",
        key: "tonkeeper"
      }
    ],
    platforms: ["ios", "android", "chrome", "firefox", "macos"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 255,
        extraCurrencySupported: true
      },
      {
        name: "SignData",
        types: ["text", "binary", "cell"]
      }
    ]
  },
  {
    app_name: "mytonwallet",
    name: "MyTonWallet",
    image: "https://static.mytonwallet.io/icon-256.png",
    about_url: "https://mytonwallet.io",
    universal_url: "https://connect.mytonwallet.org",
    deepLink: "mytonwallet-tc://",
    bridge: [
      {
        type: "js",
        key: "mytonwallet"
      },
      {
        type: "sse",
        url: "https://tonconnectbridge.mytonwallet.org/bridge/"
      }
    ],
    platforms: ["chrome", "windows", "macos", "linux", "ios", "android", "firefox"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 255,
        extraCurrencySupported: false
      },
      {
        name: "SignData",
        types: ["text", "binary", "cell"]
      }
    ]
  },
  {
    app_name: "tonhub",
    name: "Tonhub",
    image: "https://tonhub.com/tonconnect_logo.png",
    about_url: "https://tonhub.com",
    universal_url: "https://tonhub.com/ton-connect",
    bridge: [
      {
        type: "js",
        key: "tonhub"
      },
      {
        type: "sse",
        url: "https://connect.tonhubapi.com/tonconnect"
      }
    ],
    platforms: ["ios", "android"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 255,
        extraCurrencySupported: true
      },
      {
        name: "SignData",
        types: ["text", "binary", "cell"]
      }
    ]
  },
  {
    app_name: "bitgetTonWallet",
    name: "Bitget Wallet",
    image: "https://raw.githubusercontent.com/bitgetwallet/download/refs/heads/main/logo/png/bitget_wallet_logo_288_mini.png",
    about_url: "https://web3.bitget.com",
    deepLink: "bitkeep://",
    bridge: [
      {
        type: "js",
        key: "bitgetTonWallet"
      },
      {
        type: "sse",
        url: "https://ton-connect-bridge.bgwapi.io/bridge"
      }
    ],
    platforms: ["ios", "android", "chrome"],
    universal_url: "https://bkcode.vip/ton-connect",
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "okxMiniWallet",
    name: "OKX Mini Wallet",
    image: "https://static.okx.com/cdn/assets/imgs/2411/8BE1A4A434D8F58A.png",
    about_url: "https://www.okx.com/web3",
    universal_url: "https://t.me/OKX_WALLET_BOT?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://www.okx.com/tonbridge/discover/rpc/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "binanceWeb3TonWallet",
    name: "Binance Wallet",
    image: "https://public.bnbstatic.com/static/binance-w3w/ton-provider/binancew3w.png",
    about_url: "https://www.binance.com/en/web3wallet",
    deepLink: "bnc://app.binance.com/cedefi/ton-connect",
    bridge: [
      {
        type: "js",
        key: "binancew3w"
      },
      {
        type: "sse",
        url: "https://wallet.binance.com/tonbridge/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"],
    universal_url: "https://app.binance.com/cedefi/ton-connect",
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "fintopio-tg",
    name: "Fintopio",
    image: "https://raw.githubusercontent.com/fintopio/ton-pub/refs/heads/main/logos/tonconnect-icon.png",
    about_url: "https://fintopio.com",
    universal_url: "https://t.me/fintopio?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://wallet-bridge.fintopio.com/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "okxTonWallet",
    name: "OKX Wallet",
    image: "https://static.okx.com/cdn/assets/imgs/247/58E63FEA47A2B7D7.png",
    about_url: "https://www.okx.com/web3",
    universal_url: "https://www.okx.com/download?appendQuery=true&deeplink=okx://web3/wallet/tonconnect",
    bridge: [
      {
        type: "js",
        key: "okxTonWallet"
      },
      {
        type: "sse",
        url: "https://www.okx.com/tonbridge/discover/rpc/bridge"
      }
    ],
    platforms: ["chrome", "safari", "firefox", "ios", "android"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "hot",
    name: "HOT",
    image: "https://raw.githubusercontent.com/hot-dao/media/main/logo.png",
    about_url: "https://hot-labs.org/",
    universal_url: "https://t.me/herewalletbot?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://sse-bridge.hot-labs.org"
      },
      {
        type: "js",
        key: "hotWallet"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "bybitTonWallet",
    name: "Bybit Wallet",
    image: "https://raw.githubusercontent.com/bybit-web3/bybit-web3.github.io/main/docs/images/bybit-logo.png",
    about_url: "https://www.bybit.com/web3",
    universal_url: "https://app.bybit.com/ton-connect",
    deepLink: "bybitapp://",
    bridge: [
      {
        type: "js",
        key: "bybitTonWallet"
      },
      {
        type: "sse",
        url: "https://api-node.bybit.com/spot/api/web3/bridge/ton/bridge"
      }
    ],
    platforms: ["ios", "android", "chrome"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "dewallet",
    name: "DeWallet",
    image: "https://raw.githubusercontent.com/delab-team/manifests-images/main/WalletAvatar.png",
    about_url: "https://delabwallet.com",
    universal_url: "https://t.me/dewallet?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://bridge.dewallet.pro/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "safepalwallet",
    name: "SafePal",
    image: "https://s.pvcliping.com/web/public_image/SafePal_x288.png",
    tondns: "",
    about_url: "https://www.safepal.com",
    universal_url: "https://link.safepal.io/ton-connect",
    deepLink: "safepal-tc://",
    bridge: [
      {
        type: "sse",
        url: "https://ton-bridge.safepal.com/tonbridge/v1/bridge"
      },
      {
        type: "js",
        key: "safepalwallet"
      }
    ],
    platforms: ["ios", "android", "chrome", "firefox"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 1,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "GateWallet",
    name: "GateWallet",
    image: "https://img.gatedataimg.com/prd-ordinal-imgs/036f07bb8730716e/gateio-0925.png",
    about_url: "https://www.gate.io/",
    bridge: [
      {
        type: "js",
        key: "gatetonwallet"
      },
      {
        type: "sse",
        url: "https://dapp.gateio.services/tonbridge_api/bridge/v1"
      }
    ],
    platforms: ["ios", "android"],
    universal_url: "https://gate.onelink.me/Hls0/web3?gate_web3_wallet_universal_type=ton_connect",
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "openmask",
    name: "OpenMask",
    image: "https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png",
    about_url: "https://www.openmask.app/",
    bridge: [
      {
        type: "js",
        key: "openmask"
      }
    ],
    platforms: ["chrome"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "BitgetWeb3",
    name: "BitgetWeb3",
    image: "https://img.bitgetimg.com/image/third/1731638059795.png",
    about_url: "https://www.bitget.com",
    universal_url: "https://t.me/BitgetOfficialBot?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://ton-connect-bridge.bgwapi.io/bridge"
      }
    ],
    platforms: ["ios", "android", "windows", "macos", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "xtonwallet",
    name: "XTONWallet",
    image: "https://xtonwallet.com/assets/img/icon-256-back.png",
    about_url: "https://xtonwallet.com",
    bridge: [
      {
        type: "js",
        key: "xtonwallet"
      }
    ],
    platforms: ["chrome", "firefox"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 1,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "tonwallet",
    name: "TON Wallet",
    image: "https://wallet.ton.org/assets/ui/qr-logo.png",
    about_url: "https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd",
    bridge: [
      {
        type: "js",
        key: "tonwallet"
      }
    ],
    platforms: ["chrome"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "bitgetWalletLite",
    name: "Bitget Wallet Lite",
    image: "https://raw.githubusercontent.com/bitgetwallet/download/refs/heads/main/logo/png/bitget_wallet_lite_logo_288.png",
    about_url: "https://web3.bitget.com",
    universal_url: "https://t.me/BitgetWallet_TGBot?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://ton-connect-bridge.bgwapi.io/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 255,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "tomoWallet",
    name: "Tomo Wallet",
    image: "https://pub.tomo.inc/logo.png",
    about_url: "https://www.tomo.inc/",
    universal_url: "https://t.me/tomowalletbot?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://go-bridge.tomo.inc/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "miraiapp-tg",
    name: "Mirai Mini App",
    image: "https://cdn.mirailabs.co/miraihub/miraiapp-tg-icon-288.png",
    about_url: "https://mirai.app",
    universal_url: "https://t.me/MiraiAppBot?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://bridge.mirai.app"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 255,
        extraCurrencySupported: false
      },
      {
        name: "SignData",
        types: ["text", "binary", "cell"]
      }
    ]
  },
  {
    app_name: "Architec.ton",
    name: "Architec.ton",
    image: "https://raw.githubusercontent.com/Architec-Ton/wallet-tma/refs/heads/dev/public/images/arcwallet_logo.png",
    about_url: "https://architecton.tech",
    universal_url: "https://t.me/architec_ton_bot?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://tc.architecton.su/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 255,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "tokenpocket",
    name: "TokenPocket",
    image: "https://hk.tpstatic.net/logo/tokenpocket.png",
    about_url: "https://www.tokenpocket.pro",
    universal_url: "https://tp-lab.tptool.pro/ton-connect/",
    bridge: [
      {
        type: "js",
        key: "tokenpocket"
      },
      {
        type: "sse",
        url: "https://ton-connect.mytokenpocket.vip/bridge"
      }
    ],
    platforms: ["ios", "android"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "uxuyWallet",
    name: "UXUY Wallet",
    image: "https://chain-cdn.uxuy.com/logo/square_288.png",
    about_url: "https://docs.uxuy.com",
    universal_url: "https://t.me/UXUYbot?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://bridge.uxuy.me/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "tonkeeper-pro",
    name: "Tonkeeper Pro",
    image: "https://tonkeeper.com/assets/tonconnect-icon-pro.png",
    tondns: "tonkeeper.ton",
    about_url: "https://tonkeeper.com/pro",
    universal_url: "https://app.tonkeeper.com/pro/ton-connect",
    deepLink: "tonkeeper-pro-tc://",
    bridge: [
      {
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
      }
    ],
    platforms: ["ios", "macos", "windows", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 255,
        extraCurrencySupported: true
      },
      {
        name: "SignData",
        types: ["text", "binary", "cell"]
      }
    ]
  },
  {
    app_name: "nicegramWallet",
    name: "Nicegram Wallet",
    image: "https://static.nicegram.app/icon.png",
    about_url: "https://nicegram.app",
    universal_url: "https://nicegram.app/tc",
    deepLink: "nicegram-tc://",
    bridge: [
      {
        type: "sse",
        url: "https://tc.nicegram.app/bridge"
      },
      {
        type: "js",
        key: "nicegramWallet"
      }
    ],
    platforms: ["ios", "android"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 255,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "echoooTonWallet",
    name: "EchoooWallet",
    image: "https://cdn.echooo.xyz/front-end/source/images/logo/echooo-ton.png",
    about_url: "https://www.echooo.xyz",
    universal_url: "https://www.echooo.xyz/ton-connect",
    deepLink: "echooo://",
    bridge: [
      {
        type: "js",
        key: "echoooTonWallet"
      },
      {
        type: "sse",
        url: "https://ton-connect-bridge.echooo.link/bridge"
      }
    ],
    platforms: ["ios", "android"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 255,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "blitzwallet",
    name: "BLITZ wallet",
    image: "https://blitzwallet.cfd/wallet/public/logo.png",
    about_url: "https://blitzwallet.cfd",
    universal_url: "https://t.me/blitz_wallet_bot?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://blitzwallet.cfd/bridge/"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "koloWeb3Wallet",
    name: "Kolo",
    image: "https://raw.githubusercontent.com/onidev1/tc-assets/refs/heads/main/kolo_logo_288.png",
    about_url: "https://kolo.xyz",
    universal_url: "https://t.me/kolo?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://web3-bridge.kolo.in/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 255,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "imToken",
    name: "imToken",
    image: "https://aws-v2-cdn.token.im/orbit/token-v2/icons/logo-ton-connect.png",
    about_url: "https://token.im",
    universal_url: "https://connect.token.im/link/ton-connect",
    deepLink: "imtokenv2://link/ton-connect",
    bridge: [
      {
        type: "sse",
        url: "https://connect.token.im/tonbridge"
      },
      {
        type: "js",
        key: "imToken"
      }
    ],
    platforms: ["ios", "android"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 255,
        extraCurrencySupported: false
      }
    ]
  },
  {
    app_name: "cactuslink",
    name: "Cactus Link",
    image: "https://downloads.mycactus.com/288_cactus_link.png",
    about_url: "https://www.mycactus.com/defi-connector",
    bridge: [
      {
        type: "js",
        key: "cactuslink_ton"
      }
    ],
    platforms: ["chrome"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      },
      {
        name: "SignData",
        types: ["text", "binary"]
      }
    ]
  },
  {
    app_name: "onekey",
    name: "OneKey",
    image: "https://uni.onekey-asset.com/static/logo/onekey-x288.png",
    about_url: "https://onekey.so",
    bridge: [
      {
        type: "js",
        key: "onekeyTonWallet"
      }
    ],
    platforms: ["chrome"],
    features: [
      {
        name: "SendTransaction",
        maxMessages: 4,
        extraCurrencySupported: false
      }
    ]
  }
];
var qaModeEnabled = false;
var bannerObserver = null;
function enableQaMode() {
  qaModeEnabled = true;
  console.warn(" QA Mode enabled - validation is disabled. This is unsafe for production!");
  showQaModeBanner();
  startBannerObserver();
  addQaModeStyles();
}
function isQaModeEnabled() {
  return qaModeEnabled;
}
function showQaModeBanner() {
  if (typeof window === "undefined")
    return;
  const existingBanner = document.getElementById("ton-connect-qa-banner");
  if (existingBanner)
    return;
  const banner = document.createElement("div");
  banner.id = "ton-connect-qa-banner";
  banner.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
        color: white;
        padding: 12px 20px;
        text-align: center;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        font-weight: 600;
        font-size: 14px;
        z-index: 999999;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        animation: slideDown 0.3s ease-out;
        user-select: none;
        pointer-events: none;
    `;
  banner.innerHTML = `
         QA Mode Active - Validation Disabled (Unsafe for Production)
    `;
  const style = document.createElement("style");
  style.textContent = `
        @keyframes slideDown {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }
    `;
  document.head.appendChild(style);
  document.body.appendChild(banner);
  addQaModeStyles();
}
function addQaModeStyles() {
  if (typeof window === "undefined")
    return;
  const existingStyle = document.getElementById("ton-connect-qa-mode-styles");
  if (existingStyle)
    return;
  const style = document.createElement("style");
  style.id = "ton-connect-qa-mode-styles";
  style.textContent = `
        body.qa-mode-active {
            padding-top: 48px !important;
        }
        
        body.qa-mode-active header {
            margin-top: 48px !important;
        }
        
        body.qa-mode-active .qa-mode-control {
            top: 128px !important;
        }
    `;
  document.head.appendChild(style);
  document.body.classList.add("qa-mode-active");
}
function startBannerObserver() {
  if (typeof window === "undefined" || bannerObserver)
    return;
  bannerObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.type === "childList") {
        mutation.removedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            if (element.id === "ton-connect-qa-banner" && qaModeEnabled) {
              console.warn("QA Mode banner was removed, restoring...");
              setTimeout(() => showQaModeBanner(), 100);
            } else if (element.id === "ton-connect-qa-mode-styles" && qaModeEnabled) {
              console.warn("QA Mode styles were removed, restoring...");
              setTimeout(() => addQaModeStyles(), 100);
            }
          }
        });
      }
    });
  });
  bannerObserver.observe(document.body, {
    childList: true,
    subtree: false
  });
  bannerObserver.observe(document.head, {
    childList: true,
    subtree: false
  });
}
var WalletsListManager = class {
  constructor(options) {
    var _a;
    this.walletsListDTOCache = null;
    this.walletsListDTOCacheCreationTimestamp = null;
    if (isQaModeEnabled()) {
      this.walletsListSource = "https://raw.githubusercontent.com/ton-connect/wallets-list-staging/refs/heads/main/wallets-v2.json";
    } else {
      this.walletsListSource = (_a = options === null || options === void 0 ? void 0 : options.walletsListSource) !== null && _a !== void 0 ? _a : "https://config.ton.org/wallets-v2.json";
    }
    this.cacheTTLMs = options === null || options === void 0 ? void 0 : options.cacheTTLMs;
  }
  getWallets() {
    return __awaiter(this, void 0, void 0, function* () {
      const [walletsListDTO, currentlyInjectedWallets] = yield Promise.all([
        this.fetchWalletsListDTO(),
        this.getCurrentlyInjectedWallets()
      ]);
      return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(walletsListDTO), currentlyInjectedWallets);
    });
  }
  getEmbeddedWallet() {
    return __awaiter(this, void 0, void 0, function* () {
      const walletsList = yield this.getWallets();
      const embeddedWallets = walletsList.filter(isWalletInfoCurrentlyEmbedded);
      return embeddedWallets.length === 1 ? embeddedWallets[0] : null;
    });
  }
  fetchWalletsListDTO() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.cacheTTLMs && this.walletsListDTOCacheCreationTimestamp && Date.now() > this.walletsListDTOCacheCreationTimestamp + this.cacheTTLMs) {
        this.walletsListDTOCache = null;
      }
      if (!this.walletsListDTOCache) {
        this.walletsListDTOCache = this.fetchWalletsListFromSource();
        this.walletsListDTOCache.then(() => {
          this.walletsListDTOCacheCreationTimestamp = Date.now();
        }).catch(() => {
          this.walletsListDTOCache = null;
          this.walletsListDTOCacheCreationTimestamp = null;
        });
      }
      return this.walletsListDTOCache;
    });
  }
  fetchWalletsListFromSource() {
    return __awaiter(this, void 0, void 0, function* () {
      let walletsList = [];
      try {
        const walletsResponse = yield fetch(this.walletsListSource);
        walletsList = yield walletsResponse.json();
        if (!Array.isArray(walletsList)) {
          throw new FetchWalletsError("Wrong wallets list format, wallets list must be an array.");
        }
        const wrongFormatWallets = walletsList.filter((wallet) => !this.isCorrectWalletConfigDTO(wallet));
        if (wrongFormatWallets.length) {
          logError(`Wallet(s) ${wrongFormatWallets.map((wallet) => (wallet === null || wallet === void 0 ? void 0 : wallet.name) || "unknown").join(", ")} config format is wrong. They were removed from the wallets list.`);
          walletsList = walletsList.filter((wallet) => this.isCorrectWalletConfigDTO(wallet));
        }
      } catch (e) {
        logError(e);
        walletsList = FALLBACK_WALLETS_LIST;
      }
      return walletsList;
    });
  }
  getCurrentlyInjectedWallets() {
    if (!isQaModeEnabled()) {
      return [];
    }
    try {
      return InjectedProvider.getCurrentlyInjectedWallets();
    } catch (e) {
      logError(e);
      return [];
    }
  }
  walletConfigDTOListToWalletConfigList(walletConfigDTO) {
    return walletConfigDTO.map((walletConfigDTO2) => {
      const walletConfig = {
        name: walletConfigDTO2.name,
        appName: walletConfigDTO2.app_name,
        imageUrl: walletConfigDTO2.image,
        aboutUrl: walletConfigDTO2.about_url,
        tondns: walletConfigDTO2.tondns,
        platforms: walletConfigDTO2.platforms,
        features: walletConfigDTO2.features
      };
      walletConfigDTO2.bridge.forEach((bridge) => {
        if (bridge.type === "sse") {
          walletConfig.bridgeUrl = bridge.url;
          walletConfig.universalLink = walletConfigDTO2.universal_url;
          walletConfig.deepLink = walletConfigDTO2.deepLink;
        }
        if (bridge.type === "js") {
          const jsBridgeKey = bridge.key;
          walletConfig.jsBridgeKey = jsBridgeKey;
          walletConfig.injected = InjectedProvider.isWalletInjected(jsBridgeKey);
          walletConfig.embedded = InjectedProvider.isInsideWalletBrowser(jsBridgeKey);
        }
      });
      return walletConfig;
    });
  }
  mergeWalletsLists(list1, list2) {
    const names = new Set(list1.concat(list2).map((item) => item.name));
    return [...names.values()].map((name) => {
      const list1Item = list1.find((item) => item.name === name);
      const list2Item = list2.find((item) => item.name === name);
      return Object.assign(Object.assign({}, list1Item && Object.assign({}, list1Item)), list2Item && Object.assign({}, list2Item));
    });
  }
  // eslint-disable-next-line complexity
  isCorrectWalletConfigDTO(value) {
    if (!value || !(typeof value === "object")) {
      return false;
    }
    const containsName = "name" in value;
    const containsAppName = "app_name" in value;
    const containsImage = "image" in value;
    const containsAbout = "about_url" in value;
    const containsPlatforms = "platforms" in value;
    if (!containsName || !containsImage || !containsAbout || !containsPlatforms || !containsAppName) {
      return false;
    }
    if (!value.platforms || !Array.isArray(value.platforms) || !value.platforms.length) {
      return false;
    }
    if (!("bridge" in value) || !Array.isArray(value.bridge) || !value.bridge.length) {
      return false;
    }
    const bridge = value.bridge;
    if (bridge.some((item) => !item || typeof item !== "object" || !("type" in item))) {
      return false;
    }
    const sseBridge = bridge.find((item) => item.type === "sse");
    if (sseBridge) {
      if (!(typeof sseBridge === "object" && "url" in sseBridge) || !sseBridge.url || !value.universal_url) {
        return false;
      }
    }
    const jsBridge = bridge.find((item) => item.type === "js");
    if (jsBridge) {
      if (typeof jsBridge !== "object" || !("key" in jsBridge) || !jsBridge.key) {
        return false;
      }
    }
    return true;
  }
};
function checkSendTransactionSupport(features, options) {
  const supportsDeprecatedSendTransactionFeature = features.includes("SendTransaction");
  const sendTransactionFeature = findFeature(features, "SendTransaction");
  const requiredFeature = {
    minMessages: options.requiredMessagesNumber,
    extraCurrencyRequired: options.requireExtraCurrencies
  };
  if (!supportsDeprecatedSendTransactionFeature && !sendTransactionFeature) {
    throw new WalletNotSupportFeatureError("Wallet doesn't support SendTransaction feature.", {
      cause: { requiredFeature: { featureName: "SendTransaction", value: requiredFeature } }
    });
  }
  if (options.requireExtraCurrencies) {
    if (!sendTransactionFeature || !sendTransactionFeature.extraCurrencySupported) {
      throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Extra currencies support is required.`, {
        cause: {
          requiredFeature: { featureName: "SendTransaction", value: requiredFeature }
        }
      });
    }
  }
  if (sendTransactionFeature && sendTransactionFeature.maxMessages !== void 0) {
    if (sendTransactionFeature.maxMessages < options.requiredMessagesNumber) {
      throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${sendTransactionFeature.maxMessages}, but ${options.requiredMessagesNumber} is required.`, {
        cause: {
          requiredFeature: { featureName: "SendTransaction", value: requiredFeature }
        }
      });
    }
    return;
  }
  logWarning("Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.");
}
function checkSignDataSupport(features, options) {
  const signDataFeature = features.find((feature) => feature && typeof feature === "object" && feature.name === "SignData");
  if (!signDataFeature) {
    throw new WalletNotSupportFeatureError("Wallet doesn't support SignData feature.", {
      cause: {
        requiredFeature: {
          featureName: "SignData",
          value: { types: options.requiredTypes }
        }
      }
    });
  }
  const unsupportedTypes = options.requiredTypes.filter((requiredType) => !signDataFeature.types.includes(requiredType));
  if (unsupportedTypes.length) {
    throw new WalletNotSupportFeatureError(`Wallet doesn't support required SignData types: ${unsupportedTypes.join(", ")}.`, {
      cause: {
        requiredFeature: { featureName: "SignData", value: { types: unsupportedTypes } }
      }
    });
  }
}
function checkRequiredWalletFeatures(features, walletsRequiredFeatures) {
  if (typeof walletsRequiredFeatures !== "object") {
    return true;
  }
  const { sendTransaction, signData } = walletsRequiredFeatures;
  if (sendTransaction) {
    const feature = findFeature(features, "SendTransaction");
    if (!feature) {
      return false;
    }
    if (!checkSendTransaction(feature, sendTransaction)) {
      return false;
    }
  }
  if (signData) {
    const feature = findFeature(features, "SignData");
    if (!feature) {
      return false;
    }
    if (!checkSignData(feature, signData)) {
      return false;
    }
  }
  return true;
}
function findFeature(features, requiredFeatureName) {
  return features.find((f) => f && typeof f === "object" && f.name === requiredFeatureName);
}
function checkSendTransaction(feature, requiredFeature) {
  const correctMessagesNumber = requiredFeature.minMessages === void 0 || requiredFeature.minMessages <= feature.maxMessages;
  const correctExtraCurrency = !requiredFeature.extraCurrencyRequired || feature.extraCurrencySupported;
  return !!(correctMessagesNumber && correctExtraCurrency);
}
function checkSignData(feature, requiredFeature) {
  return requiredFeature.types.every((requiredType) => feature.types.includes(requiredType));
}
function createRequestVersionEvent() {
  return {
    type: "request-version"
  };
}
function createResponseVersionEvent(version) {
  return {
    type: "response-version",
    version
  };
}
function createVersionInfo(version) {
  return {
    ton_connect_sdk_lib: version.ton_connect_sdk_lib,
    ton_connect_ui_lib: version.ton_connect_ui_lib
  };
}
function createConnectionInfo(version, wallet) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const isTonProof = ((_a = wallet === null || wallet === void 0 ? void 0 : wallet.connectItems) === null || _a === void 0 ? void 0 : _a.tonProof) && "proof" in wallet.connectItems.tonProof;
  const authType = isTonProof ? "ton_proof" : "ton_addr";
  return {
    wallet_address: (_c = (_b = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _b === void 0 ? void 0 : _b.address) !== null && _c !== void 0 ? _c : null,
    wallet_type: (_d = wallet === null || wallet === void 0 ? void 0 : wallet.device.appName) !== null && _d !== void 0 ? _d : null,
    wallet_version: (_e = wallet === null || wallet === void 0 ? void 0 : wallet.device.appVersion) !== null && _e !== void 0 ? _e : null,
    auth_type: authType,
    custom_data: Object.assign({ chain_id: (_g = (_f = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _f === void 0 ? void 0 : _f.chain) !== null && _g !== void 0 ? _g : null, provider: (_h = wallet === null || wallet === void 0 ? void 0 : wallet.provider) !== null && _h !== void 0 ? _h : null }, createVersionInfo(version))
  };
}
function createConnectionStartedEvent(version) {
  return {
    type: "connection-started",
    custom_data: createVersionInfo(version)
  };
}
function createConnectionCompletedEvent(version, wallet) {
  return Object.assign({ type: "connection-completed", is_success: true }, createConnectionInfo(version, wallet));
}
function createConnectionErrorEvent(version, error_message, errorCode) {
  return {
    type: "connection-error",
    is_success: false,
    error_message,
    error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null,
    custom_data: createVersionInfo(version)
  };
}
function createConnectionRestoringStartedEvent(version) {
  return {
    type: "connection-restoring-started",
    custom_data: createVersionInfo(version)
  };
}
function createConnectionRestoringCompletedEvent(version, wallet) {
  return Object.assign({ type: "connection-restoring-completed", is_success: true }, createConnectionInfo(version, wallet));
}
function createConnectionRestoringErrorEvent(version, errorMessage) {
  return {
    type: "connection-restoring-error",
    is_success: false,
    error_message: errorMessage,
    custom_data: createVersionInfo(version)
  };
}
function createTransactionInfo(wallet, transaction) {
  var _a, _b, _c, _d;
  return {
    valid_until: (_a = String(transaction.validUntil)) !== null && _a !== void 0 ? _a : null,
    from: (_d = (_b = transaction.from) !== null && _b !== void 0 ? _b : (_c = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _c === void 0 ? void 0 : _c.address) !== null && _d !== void 0 ? _d : null,
    messages: transaction.messages.map((message) => {
      var _a2, _b2;
      return {
        address: (_a2 = message.address) !== null && _a2 !== void 0 ? _a2 : null,
        amount: (_b2 = message.amount) !== null && _b2 !== void 0 ? _b2 : null
      };
    })
  };
}
function createTransactionSentForSignatureEvent(version, wallet, transaction) {
  return Object.assign(Object.assign({ type: "transaction-sent-for-signature" }, createConnectionInfo(version, wallet)), createTransactionInfo(wallet, transaction));
}
function createTransactionSignedEvent(version, wallet, transaction, signedTransaction) {
  return Object.assign(Object.assign({ type: "transaction-signed", is_success: true, signed_transaction: signedTransaction.boc }, createConnectionInfo(version, wallet)), createTransactionInfo(wallet, transaction));
}
function createTransactionSigningFailedEvent(version, wallet, transaction, errorMessage, errorCode) {
  return Object.assign(Object.assign({ type: "transaction-signing-failed", is_success: false, error_message: errorMessage, error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null }, createConnectionInfo(version, wallet)), createTransactionInfo(wallet, transaction));
}
function createDataSentForSignatureEvent(version, wallet, data) {
  return Object.assign({ type: "sign-data-request-initiated", data }, createConnectionInfo(version, wallet));
}
function createDataSignedEvent(version, wallet, data, signedData) {
  return Object.assign({ type: "sign-data-request-completed", is_success: true, data, signed_data: signedData }, createConnectionInfo(version, wallet));
}
function createDataSigningFailedEvent(version, wallet, data, errorMessage, errorCode) {
  return Object.assign({ type: "sign-data-request-failed", is_success: false, data, error_message: errorMessage, error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null }, createConnectionInfo(version, wallet));
}
function createDisconnectionEvent(version, wallet, scope) {
  return Object.assign({ type: "disconnection", scope }, createConnectionInfo(version, wallet));
}
var BrowserEventDispatcher = class {
  constructor() {
    this.window = getWindow();
  }
  /**
   * Dispatches an event with the given name and details to the browser window.
   * @param eventName - The name of the event to dispatch.
   * @param eventDetails - The details of the event to dispatch.
   * @returns A promise that resolves when the event has been dispatched.
   */
  dispatchEvent(eventName, eventDetails) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      const event = new CustomEvent(eventName, { detail: eventDetails });
      (_a = this.window) === null || _a === void 0 ? void 0 : _a.dispatchEvent(event);
    });
  }
  /**
   * Adds an event listener to the browser window.
   * @param eventName - The name of the event to listen for.
   * @param listener - The listener to add.
   * @param options - The options for the listener.
   * @returns A function that removes the listener.
   */
  addEventListener(eventName, listener, options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      (_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener(eventName, listener, options);
      return () => {
        var _a2;
        return (_a2 = this.window) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(eventName, listener);
      };
    });
  }
};
var TonConnectTracker = class {
  /**
   * Version of the library.
   */
  get version() {
    return createVersionInfo({
      ton_connect_sdk_lib: this.tonConnectSdkVersion,
      ton_connect_ui_lib: this.tonConnectUiVersion
    });
  }
  constructor(options) {
    var _a;
    this.eventPrefix = "ton-connect-";
    this.tonConnectUiVersion = null;
    this.eventDispatcher = (_a = options === null || options === void 0 ? void 0 : options.eventDispatcher) !== null && _a !== void 0 ? _a : new BrowserEventDispatcher();
    this.tonConnectSdkVersion = options.tonConnectSdkVersion;
    this.init().catch();
  }
  /**
   * Called once when the tracker is created and request version other libraries.
   */
  init() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield this.setRequestVersionHandler();
        this.tonConnectUiVersion = yield this.requestTonConnectUiVersion();
      } catch (e) {
      }
    });
  }
  /**
   * Set request version handler.
   * @private
   */
  setRequestVersionHandler() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.eventDispatcher.addEventListener("ton-connect-request-version", () => __awaiter(this, void 0, void 0, function* () {
        yield this.eventDispatcher.dispatchEvent("ton-connect-response-version", createResponseVersionEvent(this.tonConnectSdkVersion));
      }));
    });
  }
  /**
   * Request TonConnect UI version.
   * @private
   */
  requestTonConnectUiVersion() {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        try {
          yield this.eventDispatcher.addEventListener("ton-connect-ui-response-version", (event) => {
            resolve(event.detail.version);
          }, { once: true });
          yield this.eventDispatcher.dispatchEvent("ton-connect-ui-request-version", createRequestVersionEvent());
        } catch (e) {
          reject(e);
        }
      }));
    });
  }
  /**
   * Emit user action event to the window.
   * @param eventDetails
   * @private
   */
  dispatchUserActionEvent(eventDetails) {
    try {
      this.eventDispatcher.dispatchEvent(`${this.eventPrefix}${eventDetails.type}`, eventDetails).catch();
    } catch (e) {
    }
  }
  /**
   * Track connection init event.
   * @param args
   */
  trackConnectionStarted(...args) {
    try {
      const event = createConnectionStartedEvent(this.version, ...args);
      this.dispatchUserActionEvent(event);
    } catch (e) {
    }
  }
  /**
   * Track connection success event.
   * @param args
   */
  trackConnectionCompleted(...args) {
    try {
      const event = createConnectionCompletedEvent(this.version, ...args);
      this.dispatchUserActionEvent(event);
    } catch (e) {
    }
  }
  /**
   * Track connection error event.
   * @param args
   */
  trackConnectionError(...args) {
    try {
      const event = createConnectionErrorEvent(this.version, ...args);
      this.dispatchUserActionEvent(event);
    } catch (e) {
    }
  }
  /**
   * Track connection restoring init event.
   * @param args
   */
  trackConnectionRestoringStarted(...args) {
    try {
      const event = createConnectionRestoringStartedEvent(this.version, ...args);
      this.dispatchUserActionEvent(event);
    } catch (e) {
    }
  }
  /**
   * Track connection restoring success event.
   * @param args
   */
  trackConnectionRestoringCompleted(...args) {
    try {
      const event = createConnectionRestoringCompletedEvent(this.version, ...args);
      this.dispatchUserActionEvent(event);
    } catch (e) {
    }
  }
  /**
   * Track connection restoring error event.
   * @param args
   */
  trackConnectionRestoringError(...args) {
    try {
      const event = createConnectionRestoringErrorEvent(this.version, ...args);
      this.dispatchUserActionEvent(event);
    } catch (e) {
    }
  }
  /**
   * Track disconnect event.
   * @param args
   */
  trackDisconnection(...args) {
    try {
      const event = createDisconnectionEvent(this.version, ...args);
      this.dispatchUserActionEvent(event);
    } catch (e) {
    }
  }
  /**
   * Track transaction init event.
   * @param args
   */
  trackTransactionSentForSignature(...args) {
    try {
      const event = createTransactionSentForSignatureEvent(this.version, ...args);
      this.dispatchUserActionEvent(event);
    } catch (e) {
    }
  }
  /**
   * Track transaction signed event.
   * @param args
   */
  trackTransactionSigned(...args) {
    try {
      const event = createTransactionSignedEvent(this.version, ...args);
      this.dispatchUserActionEvent(event);
    } catch (e) {
    }
  }
  /**
   * Track transaction error event.
   * @param args
   */
  trackTransactionSigningFailed(...args) {
    try {
      const event = createTransactionSigningFailedEvent(this.version, ...args);
      this.dispatchUserActionEvent(event);
    } catch (e) {
    }
  }
  /**
   * Track sign data init event.
   * @param args
   */
  trackDataSentForSignature(...args) {
    try {
      const event = createDataSentForSignatureEvent(this.version, ...args);
      this.dispatchUserActionEvent(event);
    } catch (e) {
    }
  }
  /**
   * Track sign data success event.
   * @param args
   */
  trackDataSigned(...args) {
    try {
      const event = createDataSignedEvent(this.version, ...args);
      this.dispatchUserActionEvent(event);
    } catch (e) {
    }
  }
  /**
   * Track sign data error event.
   * @param args
   */
  trackDataSigningFailed(...args) {
    try {
      const event = createDataSigningFailedEvent(this.version, ...args);
      this.dispatchUserActionEvent(event);
    } catch (e) {
    }
  }
};
var tonConnectSdkVersion = "3.3.1";
var bounceableTag = 17;
var noBounceableTag = 81;
var testOnlyTag = 128;
function toUserFriendlyAddress(hexAddress, testOnly = false) {
  const { wc, hex } = parseHexAddress(hexAddress);
  let tag = noBounceableTag;
  if (testOnly) {
    tag |= testOnlyTag;
  }
  const addr = new Int8Array(34);
  addr[0] = tag;
  addr[1] = wc;
  addr.set(hex, 2);
  const addressWithChecksum = new Uint8Array(36);
  addressWithChecksum.set(addr);
  addressWithChecksum.set(crc16(addr), 34);
  let addressBase64 = Base64.encode(addressWithChecksum);
  return addressBase64.replace(/\+/g, "-").replace(/\//g, "_");
}
function isValidUserFriendlyAddress(address) {
  try {
    parseUserFriendlyAddress(address);
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidRawAddress(address) {
  try {
    parseHexAddress(address);
    return true;
  } catch (_a) {
    return false;
  }
}
function parseUserFriendlyAddress(address) {
  const base64 = address.replace(/-/g, "+").replace(/_/g, "/");
  let decoded;
  try {
    decoded = Base64.decode(base64).toUint8Array();
  } catch (_a) {
    throw new WrongAddressError(`Invalid base64 encoding in address: ${address}`);
  }
  if (decoded.length !== 36) {
    throw new WrongAddressError(`Invalid address length: ${address}`);
  }
  const addr = decoded.slice(0, 34);
  const checksum = decoded.slice(34, 36);
  const calculatedChecksum = crc16(addr);
  if (!checksum.every((byte, i) => byte === calculatedChecksum[i])) {
    throw new WrongAddressError(`Invalid checksum in address: ${address}`);
  }
  let tag = addr[0];
  let isTestOnly = false;
  let isBounceable = false;
  if (tag & testOnlyTag) {
    isTestOnly = true;
    tag = tag ^ testOnlyTag;
  }
  if (tag !== bounceableTag && tag !== noBounceableTag) {
    throw new WrongAddressError(`Unknown address tag: ${tag}`);
  }
  isBounceable = tag === bounceableTag;
  let wc = null;
  if (addr[1] === 255) {
    wc = -1;
  } else {
    wc = addr[1];
  }
  const hex = addr.slice(2);
  if (wc !== 0 && wc !== -1) {
    throw new WrongAddressError(`Invalid workchain: ${wc}`);
  }
  return {
    wc,
    hex: Array.from(hex).map((b) => b.toString(16).padStart(2, "0")).join(""),
    testOnly: isTestOnly,
    isBounceable
  };
}
function parseHexAddress(hexAddress) {
  if (!hexAddress.includes(":")) {
    throw new WrongAddressError(`Wrong address ${hexAddress}. Address must include ":".`);
  }
  const parts = hexAddress.split(":");
  if (parts.length !== 2) {
    throw new WrongAddressError(`Wrong address ${hexAddress}. Address must include ":" only once.`);
  }
  const wc = parseInt(parts[0]);
  if (wc !== 0 && wc !== -1) {
    throw new WrongAddressError(`Wrong address ${hexAddress}. WC must be eq 0 or -1, but ${wc} received.`);
  }
  const hex = parts[1];
  if ((hex === null || hex === void 0 ? void 0 : hex.length) !== 64) {
    throw new WrongAddressError(`Wrong address ${hexAddress}. Hex part must be 64bytes length, but ${hex === null || hex === void 0 ? void 0 : hex.length} received.`);
  }
  return {
    wc,
    hex: hexToBytes(hex)
  };
}
function crc16(data) {
  const poly = 4129;
  let reg = 0;
  const message = new Uint8Array(data.length + 2);
  message.set(data);
  for (let byte of message) {
    let mask = 128;
    while (mask > 0) {
      reg <<= 1;
      if (byte & mask) {
        reg += 1;
      }
      mask >>= 1;
      if (reg > 65535) {
        reg &= 65535;
        reg ^= poly;
      }
    }
  }
  return new Uint8Array([Math.floor(reg / 256), reg % 256]);
}
var toByteMap = {};
for (let ord = 0; ord <= 255; ord++) {
  let s = ord.toString(16);
  if (s.length < 2) {
    s = "0" + s;
  }
  toByteMap[s] = ord;
}
function hexToBytes(hex) {
  hex = hex.toLowerCase();
  const length2 = hex.length;
  if (length2 % 2 !== 0) {
    throw new ParseHexError("Hex string must have length a multiple of 2: " + hex);
  }
  const length = length2 / 2;
  const result = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    const doubled = i * 2;
    const hexSubstring = hex.substring(doubled, doubled + 2);
    if (!toByteMap.hasOwnProperty(hexSubstring)) {
      throw new ParseHexError("Invalid hex character: " + hexSubstring);
    }
    result[i] = toByteMap[hexSubstring];
  }
  return result;
}
var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
var BASE64URL_REGEX = /^[A-Za-z0-9\-_]+$/;
var BOC_PREFIX = "te6cc";
var INTEGER_REGEX = /^-?\d+$/;
var POSITIVE_INTEGER_REGEX = /^\d+$/;
var MAX_DOMAIN_BYTES = 128;
var MAX_PAYLOAD_BYTES = 128;
var MAX_TOTAL_BYTES = 222;
function isValidNumber(value) {
  return typeof value === "number" && !isNaN(value);
}
function isValidString(value) {
  return typeof value === "string" && value.length > 0;
}
function isValidAddress(value) {
  return isValidString(value) && (isValidRawAddress(value) || isValidUserFriendlyAddress(value));
}
function isValidNetwork(value) {
  return isValidString(value) && /^-?\d+$/.test(value);
}
function isValidBoc(value) {
  return typeof value === "string" && (BASE64_REGEX.test(value) || BASE64URL_REGEX.test(value)) && value.startsWith(BOC_PREFIX);
}
function isValidObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function isValidArray(value) {
  return Array.isArray(value);
}
function hasExtraProperties(obj, allowedKeys) {
  return Object.keys(obj).some((key) => !allowedKeys.includes(key));
}
function validateSendTransactionRequest(data) {
  if (!isValidObject(data)) {
    return "Request must be an object";
  }
  const allowedKeys = ["validUntil", "network", "from", "messages"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Request contains extra properties";
  }
  if (data.validUntil) {
    if (!isValidNumber(data.validUntil)) {
      return "Incorrect 'validUntil'";
    }
    const now = Math.floor(Date.now() / 1e3);
    const fiveMinutesFromNow = now + 300;
    if (data.validUntil > fiveMinutesFromNow) {
      console.warn(`validUntil (${data.validUntil}) is more than 5 minutes from now (${now})`);
    }
  }
  if (data.network !== void 0) {
    if (!isValidNetwork(data.network)) {
      return "Invalid 'network' format";
    }
  }
  if (data.from !== void 0 && !isValidAddress(data.from)) {
    return "Invalid 'from' address format";
  }
  if (!isValidArray(data.messages) || data.messages.length === 0) {
    return "'messages' is required";
  }
  for (let i = 0; i < data.messages.length; i++) {
    const message = data.messages[i];
    const messageError = validateTransactionMessage(message, i);
    if (messageError) {
      return messageError;
    }
  }
  return null;
}
function validateTransactionMessage(message, index) {
  if (!isValidObject(message)) {
    return `Message at index ${index} must be an object`;
  }
  const allowedKeys = ["address", "amount", "stateInit", "payload", "extraCurrency"];
  if (hasExtraProperties(message, allowedKeys)) {
    return `Message at index ${index} contains extra properties`;
  }
  if (!isValidString(message.address)) {
    return `'address' is required in message at index ${index}`;
  }
  if (!isValidUserFriendlyAddress(message.address)) {
    return `Wrong 'address' format in message at index ${index}`;
  }
  if (!isValidString(message.amount)) {
    return `'amount' is required in message at index ${index}`;
  }
  if (!/^[0-9]+$/.test(message.amount)) {
    return `Incorrect 'amount' in message at index ${index}`;
  }
  if (message.stateInit !== void 0) {
    if (!isValidString(message.stateInit) || !isValidBoc(message.stateInit)) {
      return `Invalid 'stateInit' in message at index ${index}`;
    }
  }
  if (message.payload !== void 0) {
    if (!isValidString(message.payload) || !isValidBoc(message.payload)) {
      return `Invalid 'payload' in message at index ${index}`;
    }
  }
  if (message.extraCurrency !== void 0) {
    if (!isValidObject(message.extraCurrency)) {
      return `Invalid 'extraCurrency' in message at index ${index}`;
    }
    for (const [key, value] of Object.entries(message.extraCurrency)) {
      if (!INTEGER_REGEX.test(key) || typeof value !== "string" || !POSITIVE_INTEGER_REGEX.test(value)) {
        return `Invalid 'extraCurrency' format in message at index ${index}`;
      }
    }
  }
  return null;
}
function validateConnectAdditionalRequest(data) {
  if (!isValidObject(data)) {
    return "Request must be an object";
  }
  const allowedKeys = ["tonProof"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Request contains extra properties";
  }
  if (data.tonProof !== void 0) {
    if (typeof data.tonProof !== "string") {
      return "Invalid 'tonProof'";
    }
    const payload = data.tonProof;
    if (payload.length === 0) {
      return "Empty 'tonProof' payload";
    }
    const domain = getDomain();
    if (!domain) {
      return null;
    }
    const domainBytes = new TextEncoder().encode(domain).length;
    if (domainBytes > MAX_DOMAIN_BYTES) {
      return "Current domain exceeds 128 bytes limit";
    }
    const payloadBytes = new TextEncoder().encode(payload).length;
    if (payloadBytes > MAX_PAYLOAD_BYTES) {
      return "'tonProof' payload exceeds 128 bytes limit";
    }
    if (domainBytes + payloadBytes > MAX_TOTAL_BYTES) {
      return "'tonProof' domain + payload exceeds 222 bytes limit";
    }
  }
  return null;
}
function validateSignDataPayload(data) {
  if (!isValidObject(data)) {
    return "Payload must be an object";
  }
  if (!isValidString(data.type)) {
    return "'type' is required";
  }
  switch (data.type) {
    case "text":
      return validateSignDataPayloadText(data);
    case "binary":
      return validateSignDataPayloadBinary(data);
    case "cell":
      return validateSignDataPayloadCell(data);
    default:
      return "Invalid 'type' value";
  }
}
function validateSignDataPayloadText(data) {
  const allowedKeys = ["type", "text", "network", "from"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Text payload contains extra properties";
  }
  if (!isValidString(data.text)) {
    return "'text' is required";
  }
  if (data.network !== void 0) {
    if (!isValidNetwork(data.network)) {
      return "Invalid 'network' format";
    }
  }
  if (data.from !== void 0 && !isValidAddress(data.from)) {
    return "Invalid 'from'";
  }
  return null;
}
function validateSignDataPayloadBinary(data) {
  const allowedKeys = ["type", "bytes", "network", "from"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Binary payload contains extra properties";
  }
  if (!isValidString(data.bytes)) {
    return "'bytes' is required";
  }
  if (data.network !== void 0) {
    if (!isValidNetwork(data.network)) {
      return "Invalid 'network' format";
    }
  }
  if (data.from !== void 0 && !isValidAddress(data.from)) {
    return "Invalid 'from'";
  }
  return null;
}
function validateSignDataPayloadCell(data) {
  const allowedKeys = ["type", "schema", "cell", "network", "from"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Cell payload contains extra properties";
  }
  if (!isValidString(data.schema)) {
    return "'schema' is required";
  }
  if (!isValidString(data.cell)) {
    return "'cell' is required";
  }
  if (!isValidBoc(data.cell)) {
    return "Invalid 'cell' format (must be valid base64)";
  }
  if (data.network !== void 0) {
    if (!isValidNetwork(data.network)) {
      return "Invalid 'network' format";
    }
  }
  if (data.from !== void 0 && !isValidAddress(data.from)) {
    return "Invalid 'from'";
  }
  return null;
}
function validateTonProofItemReply(data) {
  if (!isValidObject(data)) {
    return "ton_proof item must be an object";
  }
  const allowedKeys = ["error", "proof", "name"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "ton_proof item contains extra properties";
  }
  const hasProof = Object.prototype.hasOwnProperty.call(data, "proof");
  const hasError = Object.prototype.hasOwnProperty.call(data, "error");
  if (!hasProof && !hasError) {
    return "'ton_proof' item must contain either 'proof' or 'error'";
  }
  if (hasProof && hasError) {
    return "'ton_proof' item must contain either 'proof' or 'error', not both";
  }
  if (hasProof) {
    const proof = data.proof;
    if (!isValidObject(proof)) {
      return "Invalid 'proof' object";
    }
    const allowedProofKeys = ["timestamp", "domain", "payload", "signature"];
    if (hasExtraProperties(proof, allowedProofKeys)) {
      return "ton_proof item contains extra properties";
    }
    if (!isValidNumber(proof.timestamp)) {
      return "Invalid 'proof.timestamp'";
    }
    const domain = proof.domain;
    if (!isValidObject(domain)) {
      return "Invalid 'proof.domain'";
    }
    if (!isValidNumber(domain.lengthBytes)) {
      return "Invalid 'proof.domain.lengthBytes'";
    }
    if (!isValidString(domain.value)) {
      return "Invalid 'proof.domain.value'";
    }
    try {
      const encoderAvailable = typeof TextEncoder !== "undefined";
      const actualLength = encoderAvailable ? new TextEncoder().encode(domain.value).length : domain.value.length;
      if (actualLength !== domain.lengthBytes) {
        return "'proof.domain.lengthBytes' does not match 'proof.domain.value'";
      }
    } catch (_a) {
    }
    if (!isValidString(proof.payload)) {
      return "Invalid 'proof.payload'";
    }
    if (!isValidString(proof.signature) || !BASE64_REGEX.test(proof.signature)) {
      return "Invalid 'proof.signature' format";
    }
  }
  if (hasError) {
    const error = data.error;
    if (!isValidObject(error)) {
      return "Invalid 'error' object";
    }
    const allowedErrorKeys = ["code", "message"];
    if (hasExtraProperties(error, allowedErrorKeys)) {
      return "ton_proof error contains extra properties";
    }
    if (!isValidNumber(error.code)) {
      return "Invalid 'error.code'";
    }
    if (!isValidString(error.message)) {
      return "Invalid 'error.message'";
    }
  }
  return null;
}
function normalizeBase64(data) {
  if (typeof data !== "string")
    return void 0;
  const paddedLength = data.length + (4 - data.length % 4) % 4;
  return data.replace(/-/g, "+").replace(/_/g, "/").padEnd(paddedLength, "=");
}
var TonConnect = class {
  /**
   * Returns available wallets list.
   */
  static getWallets() {
    return this.walletsList.getWallets();
  }
  /**
   * Shows if the wallet is connected right now.
   */
  get connected() {
    return this._wallet !== null;
  }
  /**
   * Current connected account or null if no account is connected.
   */
  get account() {
    var _a;
    return ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.account) || null;
  }
  /**
   * Current connected wallet or null if no account is connected.
   */
  get wallet() {
    return this._wallet;
  }
  set wallet(value) {
    this._wallet = value;
    this.statusChangeSubscriptions.forEach((callback) => callback(this._wallet));
  }
  constructor(options) {
    this.walletsList = new WalletsListManager();
    this._wallet = null;
    this.provider = null;
    this.statusChangeSubscriptions = [];
    this.statusChangeErrorSubscriptions = [];
    this.dappSettings = {
      manifestUrl: (options === null || options === void 0 ? void 0 : options.manifestUrl) || getWebPageManifest(),
      storage: (options === null || options === void 0 ? void 0 : options.storage) || new DefaultStorage()
    };
    this.walletsRequiredFeatures = options === null || options === void 0 ? void 0 : options.walletsRequiredFeatures;
    this.walletsList = new WalletsListManager({
      walletsListSource: options === null || options === void 0 ? void 0 : options.walletsListSource,
      cacheTTLMs: options === null || options === void 0 ? void 0 : options.walletsListCacheTTLMs
    });
    this.tracker = new TonConnectTracker({
      eventDispatcher: options === null || options === void 0 ? void 0 : options.eventDispatcher,
      tonConnectSdkVersion
    });
    if (!this.dappSettings.manifestUrl) {
      throw new DappMetadataError("Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest");
    }
    this.bridgeConnectionStorage = new BridgeConnectionStorage(this.dappSettings.storage);
    if (!(options === null || options === void 0 ? void 0 : options.disableAutoPauseConnection)) {
      this.addWindowFocusAndBlurSubscriptions();
    }
  }
  /**
   * Returns available wallets list.
   */
  getWallets() {
    return this.walletsList.getWallets();
  }
  /**
   * Allows to subscribe to connection status changes and handle connection errors.
   * @param callback will be called after connections status changes with actual wallet or null.
   * @param errorsHandler (optional) will be called with some instance of TonConnectError when connect error is received.
   * @returns unsubscribe callback.
   */
  onStatusChange(callback, errorsHandler) {
    this.statusChangeSubscriptions.push(callback);
    if (errorsHandler) {
      this.statusChangeErrorSubscriptions.push(errorsHandler);
    }
    return () => {
      this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter((item) => item !== callback);
      if (errorsHandler) {
        this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter((item) => item !== errorsHandler);
      }
    };
  }
  connect(wallet, requestOrOptions) {
    var _a, _b;
    const options = {};
    if (typeof requestOrOptions === "object" && "tonProof" in requestOrOptions) {
      options.request = requestOrOptions;
    }
    if (typeof requestOrOptions === "object" && ("openingDeadlineMS" in requestOrOptions || "signal" in requestOrOptions || "request" in requestOrOptions)) {
      options.request = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.request;
      options.openingDeadlineMS = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.openingDeadlineMS;
      options.signal = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.signal;
    }
    if (options.request) {
      const validationError = validateConnectAdditionalRequest(options.request);
      if (validationError) {
        if (isQaModeEnabled()) {
          console.error("ConnectAdditionalRequest validation failed: " + validationError);
        } else {
          throw new TonConnectError("ConnectAdditionalRequest validation failed: " + validationError);
        }
      }
    }
    if (this.connected) {
      throw new WalletAlreadyConnectedError();
    }
    const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);
    (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();
    this.abortController = abortController;
    if (abortController.signal.aborted) {
      throw new TonConnectError("Connection was aborted");
    }
    (_b = this.provider) === null || _b === void 0 ? void 0 : _b.closeConnection();
    this.provider = this.createProvider(wallet);
    abortController.signal.addEventListener("abort", () => {
      var _a2;
      (_a2 = this.provider) === null || _a2 === void 0 ? void 0 : _a2.closeConnection();
      this.provider = null;
    });
    this.tracker.trackConnectionStarted();
    return this.provider.connect(this.createConnectRequest(options === null || options === void 0 ? void 0 : options.request), {
      openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,
      signal: abortController.signal
    });
  }
  /**
   * Try to restore existing session and reconnect to the corresponding wallet. Call it immediately when your app is loaded.
   */
  restoreConnection(options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      this.tracker.trackConnectionRestoringStarted();
      const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);
      (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();
      this.abortController = abortController;
      if (abortController.signal.aborted) {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      const [bridgeConnectionType, embeddedWallet] = yield Promise.all([
        this.bridgeConnectionStorage.storedConnectionType(),
        this.walletsList.getEmbeddedWallet()
      ]);
      if (abortController.signal.aborted) {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      let provider = null;
      try {
        switch (bridgeConnectionType) {
          case "http":
            provider = yield BridgeProvider.fromStorage(this.dappSettings.storage);
            break;
          case "injected":
            provider = yield InjectedProvider.fromStorage(this.dappSettings.storage);
            break;
          default:
            if (embeddedWallet) {
              provider = this.createProvider(embeddedWallet);
            } else {
              return;
            }
        }
      } catch (_c) {
        this.tracker.trackConnectionRestoringError("Provider is not restored");
        yield this.bridgeConnectionStorage.removeConnection();
        provider === null || provider === void 0 ? void 0 : provider.closeConnection();
        provider = null;
        return;
      }
      if (abortController.signal.aborted) {
        provider === null || provider === void 0 ? void 0 : provider.closeConnection();
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      if (!provider) {
        logError("Provider is not restored");
        this.tracker.trackConnectionRestoringError("Provider is not restored");
        return;
      }
      (_b = this.provider) === null || _b === void 0 ? void 0 : _b.closeConnection();
      this.provider = provider;
      provider.listen(this.walletEventsListener.bind(this));
      const onAbortRestore = () => {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        provider === null || provider === void 0 ? void 0 : provider.closeConnection();
        provider = null;
      };
      abortController.signal.addEventListener("abort", onAbortRestore);
      const restoreConnectionTask = callForSuccess((_options) => __awaiter(this, void 0, void 0, function* () {
        yield provider === null || provider === void 0 ? void 0 : provider.restoreConnection({
          openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,
          signal: _options.signal
        });
        abortController.signal.removeEventListener("abort", onAbortRestore);
        if (this.connected) {
          this.tracker.trackConnectionRestoringCompleted(this.wallet);
        } else {
          this.tracker.trackConnectionRestoringError("Connection restoring failed");
        }
      }), {
        attempts: Number.MAX_SAFE_INTEGER,
        delayMs: 2e3,
        signal: options === null || options === void 0 ? void 0 : options.signal
      });
      const restoreConnectionTimeout = new Promise(
        (resolve) => setTimeout(() => resolve(), 12e3)
        // connection deadline
      );
      return Promise.race([restoreConnectionTask, restoreConnectionTimeout]);
    });
  }
  sendTransaction(transaction, optionsOrOnRequestSent) {
    return __awaiter(this, void 0, void 0, function* () {
      const options = {};
      if (typeof optionsOrOnRequestSent === "function") {
        options.onRequestSent = optionsOrOnRequestSent;
      } else {
        options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;
        options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;
      }
      const validationError = validateSendTransactionRequest(transaction);
      if (validationError) {
        if (isQaModeEnabled()) {
          console.error("SendTransactionRequest validation failed: " + validationError);
        } else {
          throw new TonConnectError("SendTransactionRequest validation failed: " + validationError);
        }
      }
      const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);
      if (abortController.signal.aborted) {
        throw new TonConnectError("Transaction sending was aborted");
      }
      this.checkConnection();
      const requiredMessagesNumber = transaction.messages.length;
      const requireExtraCurrencies = transaction.messages.some((m) => m.extraCurrency && Object.keys(m.extraCurrency).length > 0);
      checkSendTransactionSupport(this.wallet.device.features, {
        requiredMessagesNumber,
        requireExtraCurrencies
      });
      this.tracker.trackTransactionSentForSignature(this.wallet, transaction);
      const { validUntil, messages } = transaction, tx = __rest(transaction, ["validUntil", "messages"]);
      const from = transaction.from || this.account.address;
      const network = transaction.network || this.account.chain;
      const response = yield this.provider.sendRequest(sendTransactionParser.convertToRpcRequest(Object.assign(Object.assign({}, tx), {
        from,
        network,
        valid_until: validUntil,
        messages: messages.map((_a) => {
          var { extraCurrency, payload, stateInit } = _a, msg = __rest(_a, ["extraCurrency", "payload", "stateInit"]);
          return Object.assign(Object.assign({}, msg), { payload: normalizeBase64(payload), stateInit: normalizeBase64(stateInit), extra_currency: extraCurrency });
        })
      })), { onRequestSent: options.onRequestSent, signal: abortController.signal });
      if (sendTransactionParser.isError(response)) {
        this.tracker.trackTransactionSigningFailed(this.wallet, transaction, response.error.message, response.error.code);
        return sendTransactionParser.parseAndThrowError(response);
      }
      const result = sendTransactionParser.convertFromRpcResponse(response);
      this.tracker.trackTransactionSigned(this.wallet, transaction, result);
      return result;
    });
  }
  signData(data, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);
      if (abortController.signal.aborted) {
        throw new TonConnectError("data sending was aborted");
      }
      const validationError = validateSignDataPayload(data);
      if (validationError) {
        if (isQaModeEnabled()) {
          console.error("SignDataPayload validation failed: " + validationError);
        } else {
          throw new TonConnectError("SignDataPayload validation failed: " + validationError);
        }
      }
      this.checkConnection();
      checkSignDataSupport(this.wallet.device.features, { requiredTypes: [data.type] });
      this.tracker.trackDataSentForSignature(this.wallet, data);
      const from = data.from || this.account.address;
      const network = data.network || this.account.chain;
      const response = yield this.provider.sendRequest(signDataParser.convertToRpcRequest(Object.assign(Object.assign(Object.assign({}, data), data.type === "cell" ? { cell: normalizeBase64(data.cell) } : {}), {
        from,
        network
      })), { onRequestSent: options === null || options === void 0 ? void 0 : options.onRequestSent, signal: abortController.signal });
      if (signDataParser.isError(response)) {
        this.tracker.trackDataSigningFailed(this.wallet, data, response.error.message, response.error.code);
        return signDataParser.parseAndThrowError(response);
      }
      const result = signDataParser.convertFromRpcResponse(response);
      this.tracker.trackDataSigned(this.wallet, data, result);
      return result;
    });
  }
  /**
   * Disconnect form thw connected wallet and drop current session.
   */
  disconnect(options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      if (!this.connected) {
        throw new WalletNotConnectedError();
      }
      const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);
      const prevAbortController = this.abortController;
      this.abortController = abortController;
      if (abortController.signal.aborted) {
        throw new TonConnectError("Disconnect was aborted");
      }
      this.onWalletDisconnected("dapp");
      yield (_a = this.provider) === null || _a === void 0 ? void 0 : _a.disconnect({
        signal: abortController.signal
      });
      prevAbortController === null || prevAbortController === void 0 ? void 0 : prevAbortController.abort();
    });
  }
  /**
   * Gets the current session ID if available.
   * @returns session ID string or null if not available.
   */
  getSessionId() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.provider || !this.connected) {
        return null;
      }
      try {
        const connection = yield this.bridgeConnectionStorage.getConnection();
        if (!connection || connection.type === "injected") {
          return null;
        }
        if ("sessionCrypto" in connection) {
          return connection.sessionCrypto.sessionId;
        } else {
          return connection.session.sessionCrypto.sessionId;
        }
      } catch (_a) {
        return null;
      }
    });
  }
  /**
   * Pause bridge HTTP connection. Might be helpful, if you want to pause connections while browser tab is unfocused,
   * or if you use SDK with NodeJS and want to save server resources.
   */
  pauseConnection() {
    var _a;
    if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== "http") {
      return;
    }
    this.provider.pause();
  }
  /**
   * Unpause bridge HTTP connection if it is paused.
   */
  unPauseConnection() {
    var _a;
    if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== "http") {
      return Promise.resolve();
    }
    return this.provider.unPause();
  }
  addWindowFocusAndBlurSubscriptions() {
    const document2 = getDocument();
    if (!document2) {
      return;
    }
    try {
      document2.addEventListener("visibilitychange", () => {
        if (document2.hidden) {
          this.pauseConnection();
        } else {
          this.unPauseConnection().catch(() => {
          });
        }
      });
    } catch (e) {
      logError("Cannot subscribe to the document.visibilitychange: ", e);
    }
  }
  createProvider(wallet) {
    let provider;
    if (!Array.isArray(wallet) && isWalletConnectionSourceJS(wallet)) {
      provider = new InjectedProvider(this.dappSettings.storage, wallet.jsBridgeKey);
    } else {
      provider = new BridgeProvider(this.dappSettings.storage, wallet);
    }
    provider.listen(this.walletEventsListener.bind(this));
    return provider;
  }
  walletEventsListener(e) {
    switch (e.event) {
      case "connect":
        this.onWalletConnected(e.payload);
        break;
      case "connect_error":
        this.tracker.trackConnectionError(e.payload.message, e.payload.code);
        const walletError = connectErrorsParser.parseError(e.payload);
        this.onWalletConnectError(walletError);
        break;
      case "disconnect":
        this.onWalletDisconnected("wallet");
    }
  }
  onWalletConnected(connectEvent) {
    var _a;
    const tonAccountItem = connectEvent.items.find((item) => item.name === "ton_addr");
    const tonProofItem = connectEvent.items.find((item) => item.name === "ton_proof");
    if (!tonAccountItem) {
      throw new TonConnectError("ton_addr connection item was not found");
    }
    const hasRequiredFeatures = checkRequiredWalletFeatures(connectEvent.device.features, this.walletsRequiredFeatures);
    if (!hasRequiredFeatures) {
      (_a = this.provider) === null || _a === void 0 ? void 0 : _a.disconnect();
      this.onWalletConnectError(new WalletMissingRequiredFeaturesError("Wallet does not support required features", { cause: { connectEvent } }));
      return;
    }
    const wallet = {
      device: connectEvent.device,
      provider: this.provider.type,
      account: {
        address: tonAccountItem.address,
        chain: tonAccountItem.network,
        walletStateInit: tonAccountItem.walletStateInit,
        publicKey: tonAccountItem.publicKey
      }
    };
    if (tonProofItem) {
      const validationError = validateTonProofItemReply(tonProofItem);
      let tonProof = void 0;
      if (validationError) {
        if (isQaModeEnabled()) {
          console.error("TonProofItem validation failed: " + validationError);
        }
        tonProof = {
          name: "ton_proof",
          error: {
            code: CONNECT_ITEM_ERROR_CODES.UNKNOWN_ERROR,
            message: validationError
          }
        };
      } else {
        try {
          if ("proof" in tonProofItem) {
            tonProof = {
              name: "ton_proof",
              proof: {
                timestamp: tonProofItem.proof.timestamp,
                domain: {
                  lengthBytes: tonProofItem.proof.domain.lengthBytes,
                  value: tonProofItem.proof.domain.value
                },
                payload: tonProofItem.proof.payload,
                signature: tonProofItem.proof.signature
              }
            };
          } else if ("error" in tonProofItem) {
            tonProof = {
              name: "ton_proof",
              error: {
                code: tonProofItem.error.code,
                message: tonProofItem.error.message
              }
            };
          } else {
            throw new TonConnectError("Invalid data format");
          }
        } catch (e) {
          tonProof = {
            name: "ton_proof",
            error: {
              code: CONNECT_ITEM_ERROR_CODES.UNKNOWN_ERROR,
              message: "Invalid data format"
            }
          };
        }
      }
      wallet.connectItems = { tonProof };
    }
    this.wallet = wallet;
    this.tracker.trackConnectionCompleted(wallet);
  }
  onWalletConnectError(error) {
    this.statusChangeErrorSubscriptions.forEach((errorsHandler) => errorsHandler(error));
    logDebug(error);
    if (error instanceof ManifestNotFoundError || error instanceof ManifestContentErrorError) {
      logError(error);
      throw error;
    }
  }
  onWalletDisconnected(scope) {
    this.tracker.trackDisconnection(this.wallet, scope);
    this.wallet = null;
  }
  checkConnection() {
    if (!this.connected) {
      throw new WalletNotConnectedError();
    }
  }
  createConnectRequest(request) {
    const items = [
      {
        name: "ton_addr"
      }
    ];
    if (request === null || request === void 0 ? void 0 : request.tonProof) {
      items.push({
        name: "ton_proof",
        payload: request.tonProof
      });
    }
    return {
      manifestUrl: this.dappSettings.manifestUrl,
      items
    };
  }
};
TonConnect.walletsList = new WalletsListManager();
TonConnect.isWalletInjected = (walletJSKey) => InjectedProvider.isWalletInjected(walletJSKey);
TonConnect.isInsideWalletBrowser = (walletJSKey) => InjectedProvider.isInsideWalletBrowser(walletJSKey);

export {
  CONNECT_EVENT_ERROR_CODES,
  CONNECT_ITEM_ERROR_CODES,
  SEND_TRANSACTION_ERROR_CODES,
  SIGN_DATA_ERROR_CODES,
  CHAIN,
  SessionCrypto,
  TonConnectError,
  WalletAlreadyConnectedError,
  WalletNotConnectedError,
  WalletNotInjectedError,
  WalletNotSupportFeatureError,
  WalletMissingRequiredFeaturesError,
  UserRejectsError,
  BadRequestError,
  UnknownAppError,
  LocalstorageNotFoundError,
  FetchWalletsError,
  WrongAddressError,
  ParseHexError,
  UnknownError,
  isTelegramUrl,
  encodeTelegramUrlParameters,
  isWalletInfoCurrentlyInjected,
  isWalletInfoCurrentlyEmbedded,
  isWalletInfoInjectable,
  isWalletInfoRemote,
  isWalletInfoInjected,
  enableQaMode,
  isQaModeEnabled,
  WalletsListManager,
  checkRequiredWalletFeatures,
  createRequestVersionEvent,
  createResponseVersionEvent,
  createVersionInfo,
  createConnectionStartedEvent,
  createConnectionCompletedEvent,
  createConnectionErrorEvent,
  createConnectionRestoringStartedEvent,
  createConnectionRestoringCompletedEvent,
  createConnectionRestoringErrorEvent,
  createTransactionSentForSignatureEvent,
  createTransactionSignedEvent,
  createTransactionSigningFailedEvent,
  createDataSentForSignatureEvent,
  createDataSignedEvent,
  createDataSigningFailedEvent,
  createDisconnectionEvent,
  BrowserEventDispatcher,
  toUserFriendlyAddress,
  TonConnect
};
//# sourceMappingURL=chunk-6EVIPAQA.js.map
