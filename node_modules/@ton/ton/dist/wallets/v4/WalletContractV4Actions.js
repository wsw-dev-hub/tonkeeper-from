"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeExtendedAction = storeExtendedAction;
exports.loadExtendedAction = loadExtendedAction;
const core_1 = require("@ton/core");
function storeExtendedAction(action) {
    return (builder) => {
        switch (action.type) {
            case 'sendMsg':
                builder.storeUint(0, 8);
                for (let m of action.messages) {
                    builder.storeUint(action.sendMode ?? core_1.SendMode.NONE, 8);
                    builder.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(m)));
                }
                break;
            case 'addAndDeployPlugin':
                builder.storeUint(1, 8);
                builder.storeInt(action.workchain, 8);
                builder.storeCoins(action.forwardAmount);
                builder.storeRef((0, core_1.beginCell)().store((0, core_1.storeStateInit)(action.stateInit)));
                builder.storeRef(action.body);
                break;
            case 'addPlugin':
                builder.storeUint(2, 8);
                builder.storeInt(action.address.workChain, 8);
                builder.storeBuffer(action.address.hash);
                builder.storeCoins(action.forwardAmount);
                builder.storeUint(action.queryId ?? 0n, 64);
                break;
            case 'removePlugin':
                builder.storeUint(3, 8);
                builder.storeInt(action.address.workChain, 8);
                builder.storeBuffer(action.address.hash);
                builder.storeCoins(action.forwardAmount);
                builder.storeUint(action.queryId ?? 0n, 64);
                break;
            default:
                throw new Error(`Unsupported plugin action`);
        }
    };
}
function loadExtendedAction(slice) {
    const actionType = slice.loadUint(8);
    switch (actionType) {
        case 0: {
            const messages = [];
            let sendModeValue = undefined;
            while (slice.remainingRefs > 0) {
                if (slice.remainingBits < 8) {
                    throw new Error('Invalid sendMsg action: insufficient bits for send mode');
                }
                const mode = slice.loadUint(8);
                const messageCell = slice.loadRef();
                const message = (0, core_1.loadMessageRelaxed)(messageCell.beginParse());
                if (sendModeValue === undefined) {
                    sendModeValue = mode;
                }
                else if (sendModeValue !== mode) {
                    throw new Error('Invalid sendMsg action: mixed send modes are not supported');
                }
                messages.push(message);
            }
            return {
                type: 'sendMsg',
                messages,
                sendMode: sendModeValue,
            };
        }
        case 1: {
            const workchain = slice.loadInt(8);
            const forwardAmount = slice.loadCoins();
            const stateInit = (0, core_1.loadStateInit)(slice.loadRef().beginParse());
            const body = slice.loadRef();
            return {
                type: 'addAndDeployPlugin',
                workchain,
                stateInit,
                body,
                forwardAmount,
            };
        }
        case 2: {
            const workchain = slice.loadInt(8);
            const hash = slice.loadBuffer(32);
            const forwardAmount = slice.loadCoins();
            const queryId = slice.loadUintBig(64);
            return {
                type: 'addPlugin',
                address: new core_1.Address(workchain, hash),
                forwardAmount,
                queryId: queryId === 0n ? undefined : queryId,
            };
        }
        case 3: {
            const workchain = slice.loadInt(8);
            const hash = slice.loadBuffer(32);
            const forwardAmount = slice.loadCoins();
            const queryId = slice.loadUintBig(64);
            return {
                type: 'removePlugin',
                address: new core_1.Address(workchain, hash),
                forwardAmount,
                queryId: queryId === 0n ? undefined : queryId,
            };
        }
        default:
            throw new Error(`Unsupported action with opcode ${actionType}`);
    }
}
