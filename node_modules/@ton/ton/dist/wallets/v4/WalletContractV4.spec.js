"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const randomTestKey_1 = require("../../utils/randomTestKey");
const testWallets_1 = require("../../utils/testWallets");
const WalletContractV4_1 = require("./WalletContractV4");
const createTestClient4_1 = require("../../utils/createTestClient4");
const core_1 = require("@ton/core");
describe('WalletContractV4', () => {
    it('should has balance and correct address', async () => {
        // Create contract
        let client = (0, createTestClient4_1.createTestClient4)();
        let key = (0, randomTestKey_1.randomTestKey)('v4-treasure');
        let contract = client.open(WalletContractV4_1.WalletContractV4.create({ workchain: 0, publicKey: key.publicKey }));
        let balance = await contract.getBalance();
        // Check parameters
        expect(contract.address.equals(core_1.Address.parse('EQDnBF4JTFKHTYjulEJyNd4dstLGH1m51UrLdu01_tw4z2Au'))).toBe(true);
        expect(balance > 0n).toBe(true);
    });
    it('should perform transfer', async () => {
        // Create contract
        let client = (0, createTestClient4_1.createTestClient4)();
        let key = (0, randomTestKey_1.randomTestKey)('v4-treasure');
        let contract = client.open(WalletContractV4_1.WalletContractV4.create({ workchain: 0, publicKey: key.publicKey }));
        // Prepare transfer
        let seqno = await contract.getSeqno();
        let transfer = contract.createTransfer({
            seqno,
            secretKey: key.secretKey,
            messages: [(0, core_1.internal)({
                    to: 'kQD6oPnzaaAMRW24R8F0_nlSsJQni0cGHntR027eT9_sgtwt',
                    value: '0.1',
                    body: 'Hello world: 1'
                }), (0, core_1.internal)({
                    to: 'kQD6oPnzaaAMRW24R8F0_nlSsJQni0cGHntR027eT9_sgtwt',
                    value: '0.1',
                    body: 'Hello world: 2'
                })]
        });
        // Perform transfer
        await contract.send(transfer);
        // Awaiting update
        await (0, testWallets_1.tillNextSeqno)(contract, seqno);
    });
    it('should perform extra currency transfer', async () => {
        // Create contract
        let client = (0, createTestClient4_1.createTestClient4)();
        let key = (0, randomTestKey_1.randomTestKey)('v4-treasure');
        let contract = client.open(WalletContractV4_1.WalletContractV4.create({ workchain: 0, publicKey: key.publicKey }));
        // Prepare transfer
        let seqno = await contract.getSeqno();
        let transfer = contract.createTransfer({
            seqno,
            secretKey: key.secretKey,
            messages: [(0, core_1.internal)({
                    to: 'kQD6oPnzaaAMRW24R8F0_nlSsJQni0cGHntR027eT9_sgtwt',
                    value: '0.01',
                    extracurrency: { 100: BigInt(10 ** 6) },
                    body: 'Hello extra currency v4'
                })]
        });
        // Perform transfer
        await contract.send(transfer);
        // Awaiting update
        await (0, testWallets_1.tillNextSeqno)(contract, seqno);
    });
    describe('plugins', () => {
        let client;
        let walletKey;
        let contract;
        let randomAddress;
        let pluginKey;
        let pluginContract;
        beforeEach(() => {
            client = (0, createTestClient4_1.createTestClient4)();
            walletKey = (0, randomTestKey_1.randomTestKey)('v4-treasure');
            contract = client.open(WalletContractV4_1.WalletContractV4.create({ workchain: 0, publicKey: walletKey.publicKey }));
            pluginContract = client.open(WalletContractV4_1.WalletContractV4.create({ workchain: 0, publicKey: walletKey.publicKey }));
            randomAddress = WalletContractV4_1.WalletContractV4.create({
                workchain: 0,
                publicKey: (0, randomTestKey_1.randomTestKey)('v4-test-plugin').publicKey
            }).address;
        });
        it('should install plugin', async () => {
            let seqno = await contract.getSeqno();
            await contract.sendRequest({
                seqno: await contract.getSeqno(),
                secretKey: walletKey.secretKey,
                action: {
                    type: 'addPlugin',
                    address: randomAddress,
                    forwardAmount: (0, core_1.toNano)('0.01'),
                }
            });
            await (0, testWallets_1.tillNextSeqno)(contract, seqno);
        });
        it('should return plugin in get methods', async () => {
            expect(await contract.getIsPluginInstalled(randomAddress)).toBeTruthy();
            const plugins = await contract.getPluginsArray();
            expect(plugins.find(plugin => plugin.equals(randomAddress))).toBeTruthy();
        });
        it('should uninstall plugin', async () => {
            let seqno = await contract.getSeqno();
            await contract.sendRequest({
                seqno: await contract.getSeqno(),
                secretKey: walletKey.secretKey,
                action: {
                    type: 'removePlugin',
                    address: randomAddress,
                    forwardAmount: (0, core_1.toNano)('0.01'),
                }
            });
            await (0, testWallets_1.tillNextSeqno)(contract, seqno);
        });
        it('should return plugin in get methods', async () => {
            expect(await contract.getIsPluginInstalled(randomAddress)).toBeFalsy();
            const plugins = await contract.getPluginsArray();
            plugins.forEach(plugin => {
                expect(plugin.equals(randomAddress)).toBeFalsy();
            });
        });
        it('should install and deploy plugin', async () => {
            let seqno = await contract.getSeqno();
            await contract.sendRequest({
                seqno: await contract.getSeqno(),
                secretKey: walletKey.secretKey,
                action: {
                    type: 'addAndDeployPlugin',
                    workchain: 0,
                    stateInit: pluginContract.init,
                    body: (0, core_1.beginCell)().endCell(),
                    forwardAmount: (0, core_1.toNano)('0.1'),
                }
            });
            await (0, testWallets_1.tillNextSeqno)(contract, seqno);
        });
        it('should withdraw funds by plugin request', async () => {
            let seqno = await contract.getSeqno();
            await pluginContract.sendPluginRequestFunds(pluginContract.sender(walletKey.secretKey), {
                forwardAmount: (0, core_1.toNano)('0.01'),
                toncoinsToWithdraw: (0, core_1.toNano)('0.05')
            });
            await (0, testWallets_1.tillNextSeqno)(contract, seqno);
        });
        it('should delete plugin by plugin request', async () => {
            let seqno = await pluginContract.getSeqno();
            await pluginContract.sendPluginRemovePlugin(pluginContract.sender(walletKey.secretKey), (0, core_1.toNano)('0.01'));
            await (0, testWallets_1.tillNextSeqno)(contract, seqno);
        });
    });
});
